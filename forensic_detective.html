<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Forensic Detective - DNA Investigation Game</title>
<style>
/* ============================================ */
/* ROOT RESET AND BASE STYLES                  */
/* ============================================ */

*, *::before, *::after {
	box-sizing: border-box;
	margin: 0;
	padding: 0;
}

html {
	overflow-y: scroll;
	height: 100%;
}

body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
		Oxygen, Ubuntu, Cantarell, "Helvetica Neue", Arial, sans-serif;
	background-color: #1a1a2e;
	color: #e8e8e8;
	min-height: 100vh;
	line-height: 1.5;
}

h1, h2, h3, h4 {
	color: #d4a373;
	margin-bottom: 0.5em;
	font-weight: 600;
}

a {
	color: #d4a373;
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

/* ============================================ */
/* GAME CONTAINER                              */
/* ============================================ */

#game-container {
	width: 100%;
	min-height: 100vh;
	position: relative;
}

/* ============================================ */
/* SCREEN VISIBILITY                           */
/* ============================================ */

.screen {
	display: none;
	width: 100%;
	min-height: 100vh;
}

.screen.active {
	display: flex;
	flex-direction: column;
	align-items: center;
	justify-content: center;
	animation: fadeIn 0.4s ease-in-out;
}

@keyframes fadeIn {
	from { opacity: 0; }
	to   { opacity: 1; }
}

/* ============================================ */
/* TITLE SCREEN                                */
/* ============================================ */

#title-screen {
	background: radial-gradient(ellipse at 50% 80%, #16213e 0%, #1a1a2e 70%);
	text-align: center;
	gap: 1.2em;
	padding: 2em;
}

#mansion-silhouette {
	width: 320px;
	height: 180px;
	margin: 0 auto 1em;
	position: relative;
	background:
		/* main house body */
		linear-gradient(to bottom, #0a0a18 0%, #0a0a18 100%);
	clip-path: polygon(
		0% 100%,
		0% 45%,
		10% 45%,
		10% 30%,
		15% 30%,
		15% 20%,
		25% 20%,
		25% 10%,
		30% 10%,
		30% 25%,
		35% 25%,
		35% 35%,
		40% 35%,
		40% 15%,
		45% 5%,
		50% 0%,
		55% 5%,
		60% 15%,
		60% 35%,
		65% 35%,
		65% 25%,
		70% 25%,
		70% 10%,
		75% 10%,
		75% 20%,
		85% 20%,
		85% 30%,
		90% 30%,
		90% 45%,
		100% 45%,
		100% 100%
	);
	box-shadow:
		0 0 60px rgba(233, 69, 96, 0.15),
		0 0 120px rgba(26, 26, 46, 0.8);
}

/* lit window effect inside the mansion */
#mansion-silhouette::after {
	content: "";
	position: absolute;
	bottom: 25%;
	left: 44%;
	width: 12%;
	height: 15%;
	background: rgba(212, 163, 115, 0.35);
	box-shadow:
		-60px 10px 0 rgba(212, 163, 115, 0.2),
		60px -5px 0 rgba(233, 69, 96, 0.25);
}

#game-title {
	font-size: 3em;
	color: #d4a373;
	text-shadow: 0 0 30px rgba(233, 69, 96, 0.3);
	letter-spacing: 0.05em;
}

#game-subtitle {
	font-size: 1.3em;
	color: #8899aa;
	font-style: italic;
}

#title-buttons {
	display: flex;
	gap: 1em;
	justify-content: center;
	flex-wrap: wrap;
	margin-top: 0.5em;
}

#title-credit {
	font-size: 0.85em;
	color: #667788;
	margin-top: 1em;
}

/* ============================================ */
/* SETUP SCREEN                                */
/* ============================================ */

#setup-screen {
	padding: 2em;
	gap: 1em;
	max-width: 900px;
	margin: 0 auto;
}

#setup-form {
	width: 100%;
	display: flex;
	flex-direction: column;
	gap: 1.5em;
}

.setup-section {
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 8px;
	padding: 1.5em;
}

.setup-section h3 {
	margin-bottom: 0.8em;
}

.setup-hint {
	color: #8899aa;
	font-size: 0.9em;
	margin-bottom: 1em;
}

/* Difficulty option cards */
.option-group {
	display: flex;
	gap: 1em;
	flex-wrap: wrap;
}

.difficulty-card {
	flex: 1 1 180px;
	background: #0f3460;
	border: 2px solid #16213e;
	border-radius: 8px;
	padding: 1.2em;
	cursor: pointer;
	transition: border-color 0.2s, box-shadow 0.2s;
	text-align: center;
}

.difficulty-card:hover {
	border-color: #d4a373;
}

.difficulty-card.selected {
	border-color: #e94560;
	box-shadow: 0 0 12px rgba(233, 69, 96, 0.3);
}

.difficulty-card h4 {
	margin-bottom: 0.3em;
}

.difficulty-card p {
	font-size: 0.85em;
	color: #8899aa;
}

/* Suspect selection grid */
.suspect-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(160px, 1fr));
	gap: 0.8em;
}

.suspect-option {
	background: #0f3460;
	border: 2px solid #16213e;
	border-radius: 8px;
	padding: 1em;
	cursor: pointer;
	transition: border-color 0.2s, box-shadow 0.2s;
	text-align: center;
}

.suspect-option:hover {
	border-color: #8899aa;
}

.suspect-option.selected {
	border-color: #d4a373;
	box-shadow: 0 0 10px rgba(212, 163, 115, 0.25);
}

#suspect-count-display {
	text-align: center;
	color: #8899aa;
	margin-top: 0.8em;
	font-size: 0.9em;
}

/* ============================================ */
/* INTRO SCREEN                                */
/* ============================================ */

#intro-screen {
	background: linear-gradient(175deg, #0a0a18 0%, #1a1a2e 50%, #16213e 100%);
	padding: 3em 2em;
	gap: 2em;
	text-align: center;
	max-width: 800px;
	margin: 0 auto;
}

#intro-content {
	background: #16213e;
	border: 1px solid #0f3460;
	border-left: 4px solid #e94560;
	border-radius: 6px;
	padding: 2em;
	text-align: left;
	line-height: 1.8;
	font-size: 1.05em;
	max-width: 700px;
}

#intro-content h2 {
	color: #e94560;
	margin-bottom: 0.8em;
}

#intro-content p {
	margin-bottom: 0.8em;
}

/* ============================================ */
/* GAME SCREEN - MAIN LAYOUT                   */
/* ============================================ */

#game-screen.active {
	justify-content: flex-start;
	align-items: stretch;
}

/* Header bar */
#game-header {
	display: flex;
	align-items: center;
	justify-content: space-between;
	background: #16213e;
	border-bottom: 2px solid #0f3460;
	padding: 0.6em 1.2em;
	width: 100%;
	position: sticky;
	top: 0;
	z-index: 100;
	gap: 1em;
}

#header-left, #header-right {
	display: flex;
	align-items: center;
	gap: 1em;
	white-space: nowrap;
}

#round-display {
	color: #d4a373;
	font-weight: 600;
}

#phase-display {
	color: #8899aa;
	font-size: 0.9em;
}

#score-display {
	color: #d4a373;
	font-weight: 600;
}

/* Timer */
#timer-container {
	flex: 1;
	max-width: 300px;
	display: flex;
	align-items: center;
	gap: 0.6em;
}

#timer-bar {
	flex: 1;
	height: 14px;
	background: #0a0a18;
	border-radius: 7px;
	overflow: hidden;
	border: 1px solid #0f3460;
}

#timer-bar-fill {
	height: 100%;
	width: 100%;
	background: #4caf50;
	border-radius: 7px;
	transition: width 1s linear, background-color 0.5s ease;
}

#timer-text {
	font-family: "Courier New", Courier, monospace;
	font-size: 0.95em;
	min-width: 3.5em;
	text-align: right;
}

@keyframes pulse {
	0%, 100% { opacity: 1; }
	50%      { opacity: 0.5; }
}

.timer-critical #timer-bar-fill {
	background: #f44336;
	animation: pulse 1s ease-in-out infinite;
}

.timer-warning #timer-bar-fill {
	background: #ff9800;
}

/* Three-column game body */
#game-body {
	display: grid;
	grid-template-columns: 200px 1fr 250px;
	flex: 1;
	overflow: hidden;
	width: 100%;
}

/* Left panel: suspect cards */
#character-panel {
	background: #16213e;
	border-right: 1px solid #0f3460;
	padding: 1em;
	overflow-y: auto;
	max-height: calc(100vh - 110px);
}

#character-panel h3 {
	font-size: 1em;
	margin-bottom: 0.8em;
	text-transform: uppercase;
	letter-spacing: 0.1em;
	color: #8899aa;
}

#suspect-cards {
	display: flex;
	flex-direction: column;
	gap: 0.5em;
}

/* Center: main content area */
#main-panel {
	padding: 1.5em;
	overflow-y: auto;
	max-height: calc(100vh - 110px);
	background: #1a1a2e;
}

/* Right panel: evidence sidebar */
#evidence-sidebar {
	background: #16213e;
	border-left: 1px solid #0f3460;
	padding: 1em;
	overflow-y: auto;
	max-height: calc(100vh - 110px);
}

#evidence-sidebar h3 {
	font-size: 1em;
	margin-bottom: 0.8em;
	text-transform: uppercase;
	letter-spacing: 0.1em;
	color: #8899aa;
}

.empty-state {
	color: #667788;
	font-style: italic;
	font-size: 0.85em;
	text-align: center;
	padding: 1em 0;
}

/* ============================================ */
/* SUSPECT CARDS                               */
/* ============================================ */

.suspect-card {
	background: #0f3460;
	border: 1px solid #16213e;
	border-radius: 6px;
	padding: 0.7em 0.8em;
	position: relative;
	transition: border-color 0.2s;
}

.suspect-card:hover {
	border-color: #d4a373;
}

.suspect-card .suspect-name {
	font-weight: 600;
	font-size: 0.9em;
	color: #e8e8e8;
}

.suspect-card .suspect-role {
	font-size: 0.8em;
	color: #8899aa;
}

.suspect-card .suspect-status {
	display: inline-block;
	width: 8px;
	height: 8px;
	border-radius: 50%;
	background: #4caf50;
	position: absolute;
	top: 0.8em;
	right: 0.8em;
}

.suspect-card.dead {
	opacity: 0.45;
	border-color: #f44336;
	background: #1a1a2e;
}

.suspect-card.dead .suspect-name {
	text-decoration: line-through;
	color: #667788;
}

.suspect-card.dead .suspect-status {
	background: #f44336;
}

/* ============================================ */
/* BUTTONS                                     */
/* ============================================ */

.btn {
	display: inline-block;
	padding: 0.65em 1.4em;
	border: 2px solid transparent;
	border-radius: 6px;
	font-size: 1em;
	font-weight: 600;
	cursor: pointer;
	transition: background-color 0.2s, border-color 0.2s, opacity 0.2s;
	font-family: inherit;
	color: #e8e8e8;
	background: transparent;
	text-align: center;
}

.btn:disabled {
	opacity: 0.4;
	cursor: not-allowed;
}

.btn-primary {
	background: #e94560;
	border-color: #e94560;
	color: #ffffff;
}

.btn-primary:hover:not(:disabled) {
	background: #d13352;
	border-color: #d13352;
}

.btn-secondary {
	background: transparent;
	border-color: #d4a373;
	color: #d4a373;
}

.btn-secondary:hover:not(:disabled) {
	background: rgba(212, 163, 115, 0.1);
}

.btn-small {
	padding: 0.3em 0.7em;
	font-size: 0.85em;
	border: 1px solid #8899aa;
	color: #8899aa;
}

.btn-small:hover:not(:disabled) {
	border-color: #d4a373;
	color: #d4a373;
}

.btn-nav {
	background: #0f3460;
	border-color: #0f3460;
	padding: 0.5em 1.2em;
	font-size: 0.9em;
}

.btn-nav:hover:not(:disabled) {
	background: #16213e;
	border-color: #d4a373;
}

.btn-accent {
	background: #e94560;
	border-color: #e94560;
}

.btn-accent:hover:not(:disabled) {
	background: #d13352;
}

.btn-danger {
	background: #f44336;
	border-color: #f44336;
}

.btn-danger:hover:not(:disabled) {
	background: #d32f2f;
}

/* ============================================ */
/* PHASE NAVIGATION BAR                        */
/* ============================================ */

#phase-nav {
	display: flex;
	justify-content: center;
	gap: 0.8em;
	padding: 0.8em;
	background: #16213e;
	border-top: 2px solid #0f3460;
	width: 100%;
}

/* ============================================ */
/* MODAL OVERLAY                               */
/* ============================================ */

#modal-overlay {
	position: fixed;
	top: 0;
	left: 0;
	width: 100%;
	height: 100%;
	background: rgba(10, 10, 24, 0.85);
	display: flex;
	align-items: center;
	justify-content: center;
	z-index: 1000;
	animation: fadeIn 0.2s ease-in-out;
}

#modal-overlay.modal-hidden {
	display: none;
}

#modal-box {
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 10px;
	padding: 2em;
	max-width: 600px;
	width: 90%;
	max-height: 80vh;
	overflow-y: auto;
	position: relative;
	box-shadow: 0 8px 40px rgba(0, 0, 0, 0.6);
}

#modal-close {
	position: absolute;
	top: 0.6em;
	right: 0.6em;
	font-size: 1.2em;
	line-height: 1;
}

#modal-content h2, #modal-content h3 {
	margin-bottom: 0.6em;
}

#modal-content p {
	margin-bottom: 0.6em;
}

/* ============================================ */
/* EVIDENCE ITEMS                              */
/* ============================================ */

.evidence-item {
	background: #0f3460;
	border: 1px solid #16213e;
	border-radius: 6px;
	padding: 0.6em 0.8em;
	margin-bottom: 0.5em;
	font-size: 0.85em;
	position: relative;
	cursor: pointer;
	transition: border-color 0.2s;
}

.evidence-item:hover {
	border-color: #d4a373;
}

.evidence-item .evidence-label {
	font-weight: 600;
	color: #e8e8e8;
}

.evidence-item .evidence-detail {
	color: #8899aa;
	font-size: 0.9em;
}

/* Evidence type tags */
.evidence-tag {
	display: inline-block;
	padding: 0.15em 0.5em;
	border-radius: 3px;
	font-size: 0.75em;
	font-weight: 600;
	text-transform: uppercase;
	letter-spacing: 0.05em;
}

.evidence-tag.tag-blood    { background: rgba(244, 67, 54, 0.25); color: #f44336; }
.evidence-tag.tag-hair     { background: rgba(141, 110, 80, 0.3); color: #b8956a; }
.evidence-tag.tag-saliva   { background: rgba(76, 175, 80, 0.25); color: #4caf50; }
.evidence-tag.tag-touch    { background: rgba(33, 150, 243, 0.25); color: #2196f3; }
.evidence-tag.tag-fiber    { background: rgba(156, 39, 176, 0.25); color: #ce93d8; }

/* ============================================ */
/* SCENE INVESTIGATION PHASE                   */
/* ============================================ */

.scene-evidence-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
	gap: 1em;
	margin-top: 1em;
}

.scene-evidence-grid .evidence-item {
	padding: 1em;
	text-align: center;
}

/* ============================================ */
/* LAB PHASE                                   */
/* ============================================ */

.lab-test-panel {
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 8px;
	padding: 1.5em;
	margin-bottom: 1em;
}

.lab-test-panel h3 {
	margin-bottom: 0.8em;
}

.test-result-card {
	background: #0f3460;
	border: 1px solid #16213e;
	border-radius: 8px;
	padding: 1.2em;
	margin-bottom: 0.8em;
	border-left: 4px solid #d4a373;
}

.test-result-card h4 {
	font-size: 1em;
	margin-bottom: 0.4em;
}

.test-result-card p {
	font-size: 0.9em;
	color: #8899aa;
	margin-bottom: 0.3em;
}

/* Lab button grid layout */
.lab-section {
	margin-bottom: 1.2em;
}

.lab-section h3 {
	font-size: 1em;
	color: #d4a373;
	margin-bottom: 0.5em;
}

.lab-button-grid {
	display: flex;
	flex-wrap: wrap;
	gap: 0.5em;
}

.lab-sample-btn {
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	background: #16213e;
	border: 2px solid #0f3460;
	border-radius: 8px;
	padding: 0.6em 1em;
	color: #e0e0e0;
	cursor: pointer;
	min-width: 140px;
	transition: border-color 0.2s, background 0.2s;
}

.lab-sample-btn:hover {
	border-color: #d4a373;
	background: #1a2a50;
}

.lab-sample-btn.selected {
	border-color: #d4a373;
	background: #1a2a50;
	box-shadow: 0 0 8px rgba(212, 163, 115, 0.3);
}

.sample-btn-type {
	font-weight: bold;
	font-size: 0.85em;
	color: #d4a373;
	letter-spacing: 0.05em;
}

.sample-btn-label {
	font-size: 0.8em;
	color: #8899aa;
	margin-top: 0.2em;
}

.sample-btn-quality {
	font-size: 0.75em;
	color: #667788;
	font-style: italic;
}

.lab-test-btn {
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	background: #0f3460;
	border: 2px solid #16213e;
	border-radius: 8px;
	padding: 0.8em 1.2em;
	color: #e0e0e0;
	cursor: pointer;
	min-width: 160px;
	flex: 1;
	transition: border-color 0.2s, background 0.2s;
}

.lab-test-btn:hover:not(:disabled) {
	border-color: #4a9eff;
	background: #162f5e;
}

.lab-test-btn:disabled {
	opacity: 0.4;
	cursor: not-allowed;
}

.test-btn-name {
	font-weight: bold;
	font-size: 0.95em;
}

.test-btn-desc {
	font-size: 0.75em;
	color: #8899aa;
	margin-top: 0.2em;
}

.lab-control-toggle {
	padding: 0.3em 0;
}

.control-label {
	font-size: 0.9em;
	cursor: pointer;
}

/* Interpretation buttons */
.interpretation-buttons {
	display: flex;
	flex-direction: column;
	gap: 0.4em;
}

.interpretation-btn {
	display: flex;
	flex-direction: column;
	align-items: flex-start;
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 6px;
	padding: 0.5em 1em;
	color: #e0e0e0;
	cursor: pointer;
	text-align: left;
	width: 100%;
	transition: border-color 0.2s, background 0.2s;
}

.interpretation-btn:hover {
	border-color: #d4a373;
	background: #1a2a50;
}

.interpretation-btn strong {
	font-size: 0.9em;
}

.interpretation-btn-desc {
	font-size: 0.75em;
	color: #8899aa;
}

.interpretation-saved {
	background: #0f3460;
	border-left: 3px solid #4caf50;
	padding: 0.5em 1em;
	border-radius: 4px;
	margin-top: 0.5em;
}

/* Gel visualization container */
.gel-container {
	background: #0a0a18;
	border: 2px solid #0f3460;
	border-radius: 6px;
	padding: 1em;
	margin: 1em 0;
	text-align: center;
	overflow-x: auto;
}

.gel-container canvas {
	display: block;
	margin: 0 auto;
	max-width: 100%;
}

/* ============================================ */
/* CASE BOARD PHASE                            */
/* ============================================ */

.case-board-panel {
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 8px;
	padding: 1.5em;
	margin-bottom: 1em;
}

.case-board-panel h3 {
	color: #d4a373;
	margin-bottom: 0.8em;
}

/* Certainty dropdown selectors */
.certainty-selector {
	width: 100%;
	padding: 0.5em 0.8em;
	background: #0f3460;
	color: #e8e8e8;
	border: 1px solid #16213e;
	border-radius: 4px;
	font-size: 0.9em;
	font-family: inherit;
	cursor: pointer;
}

.certainty-selector:focus {
	outline: none;
	border-color: #d4a373;
}

/* ============================================ */
/* FORMS AND INPUTS                            */
/* ============================================ */

.form-group {
	margin-bottom: 1em;
}

.form-group label {
	display: block;
	font-weight: 600;
	color: #d4a373;
	margin-bottom: 0.3em;
	font-size: 0.9em;
}

.interpretation-input {
	width: 100%;
	min-height: 80px;
	padding: 0.7em;
	background: #0a0a18;
	color: #e8e8e8;
	border: 1px solid #0f3460;
	border-radius: 6px;
	font-family: inherit;
	font-size: 0.95em;
	resize: vertical;
	line-height: 1.5;
}

.interpretation-input:focus {
	outline: none;
	border-color: #d4a373;
}

/* ============================================ */
/* SCORE DISPLAY                               */
/* ============================================ */

.score-card {
	background: #16213e;
	border: 1px solid #0f3460;
	border-radius: 8px;
	padding: 1.5em;
	margin-bottom: 1em;
}

.score-card h3 {
	margin-bottom: 0.8em;
	text-align: center;
}

.score-row {
	display: flex;
	justify-content: space-between;
	padding: 0.4em 0;
	border-bottom: 1px solid rgba(15, 52, 96, 0.5);
	font-size: 0.95em;
}

.score-row:last-child {
	border-bottom: none;
	font-weight: 700;
	padding-top: 0.6em;
	margin-top: 0.3em;
	border-top: 2px solid #0f3460;
}

.score-positive {
	color: #4caf50;
}

.score-negative {
	color: #f44336;
}

/* ============================================ */
/* ROUND END AND GAME OVER SCREENS             */
/* ============================================ */

/* Accusation cards */
.accusation-grid {
	display: grid;
	grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
	gap: 1em;
	margin: 1em 0;
}

.accusation-card {
	background: #16213e;
	border: 2px solid #0f3460;
	border-radius: 8px;
	padding: 1.2em;
	cursor: pointer;
	transition: border-color 0.2s, background 0.2s, transform 0.1s;
}

.accusation-card:hover {
	border-color: #e74c3c;
	background: #1a2a50;
	transform: translateY(-2px);
}

.accusation-card h3 {
	color: #d4a373;
	margin-bottom: 0.3em;
}

.accusation-card .suspect-role {
	color: #8899aa;
	font-size: 0.9em;
	margin-bottom: 0.5em;
}

.accusation-card .suspect-alibi {
	font-size: 0.85em;
	color: #667788;
	font-style: italic;
}

.accusation-card .suspect-motive {
	font-size: 0.85em;
	margin-top: 0.5em;
}

.accusation-actions {
	text-align: center;
	margin-top: 1em;
}

.confirmation-buttons {
	display: flex;
	gap: 1em;
	justify-content: center;
	margin-top: 1em;
}

#round-end-screen, #accusation-screen, #game-over-screen {
	padding: 2em;
	gap: 1.5em;
	max-width: 700px;
	margin: 0 auto;
	text-align: center;
}

#game-over-content h2 {
	font-size: 2em;
}

/* ============================================ */
/* HELP PANEL                                  */
/* ============================================ */

.help-panel {
	background: #16213e;
	border: 1px solid #0f3460;
	border-left: 4px solid #d4a373;
	border-radius: 6px;
	padding: 1.5em;
	margin: 1em 0;
	font-size: 0.95em;
	line-height: 1.7;
}

.help-panel h3 {
	color: #d4a373;
	margin-bottom: 0.5em;
}

.help-panel p {
	margin-bottom: 0.5em;
	color: #8899aa;
}

/* ============================================ */
/* RESPONSIVE ADJUSTMENTS                      */
/* ============================================ */

@media (max-width: 1200px) {
	#game-body {
		grid-template-columns: 170px 1fr 220px;
	}
}

@media (max-width: 960px) {
	#game-body {
		grid-template-columns: 1fr;
	}

	#character-panel, #evidence-sidebar {
		max-height: none;
		border-right: none;
		border-left: none;
		border-bottom: 1px solid #0f3460;
	}

	#character-panel {
		display: flex;
		flex-wrap: wrap;
		gap: 0.5em;
	}

	#suspect-cards {
		flex-direction: row;
		flex-wrap: wrap;
	}

	.suspect-card {
		flex: 0 0 auto;
	}

	#main-panel {
		max-height: none;
	}
}
</style>
</head>
<body>
<!-- ============================================ -->
<!-- GAME HTML STRUCTURE                          -->
<!-- ============================================ -->

<div id="game-container">

	<!-- TITLE SCREEN -->
	<div id="title-screen" class="screen active">
		<div id="mansion-silhouette"></div>
		<h1 id="game-title">Forensic Detective</h1>
		<p id="game-subtitle">A DNA Investigation Game</p>
		<div id="title-buttons">
			<button id="btn-new-game" class="btn btn-primary" onclick="showSetupScreen()">New Investigation</button>
			<button id="btn-load-game" class="btn btn-secondary" onclick="loadAndResumeGame()">Continue Investigation</button>
		</div>
		<p id="title-credit">Learn real forensic science by solving a murder mystery</p>
	</div>

	<!-- SETUP SCREEN -->
	<div id="setup-screen" class="screen">
		<h2>Case Configuration</h2>
		<div id="setup-form">
			<div class="setup-section">
				<h3>Difficulty Level</h3>
				<div id="difficulty-options" class="option-group">
					<!-- filled by JS -->
				</div>
			</div>
			<div class="setup-section">
				<h3>Select Suspects (4-6)</h3>
				<p class="setup-hint">Choose which suspects were present at the dinner party.</p>
				<div id="suspect-selection" class="suspect-grid">
					<!-- filled by JS -->
				</div>
				<p id="suspect-count-display">Selected: 0 / 4-6 required</p>
			</div>
			<button id="btn-start-case" class="btn btn-primary" onclick="startCase()" disabled>Begin Investigation</button>
		</div>
	</div>

	<!-- INTRO BRIEFING SCREEN -->
	<div id="intro-screen" class="screen">
		<div id="intro-content">
			<!-- filled by JS -->
		</div>
		<button id="btn-enter-scene" class="btn btn-primary" onclick="enterScenePhase()">Proceed to Crime Scene</button>
	</div>

	<!-- MAIN GAME SCREEN -->
	<div id="game-screen" class="screen">

		<!-- Header bar: timer, round, score -->
		<div id="game-header">
			<div id="header-left">
				<span id="round-display">Round 1</span>
				<span id="phase-display">Scene Investigation</span>
			</div>
			<div id="timer-container">
				<div id="timer-bar">
					<div id="timer-bar-fill"></div>
				</div>
				<span id="timer-text">5:00</span>
			</div>
			<div id="header-right">
				<span id="score-display">Score: 0</span>
				<button id="btn-help" class="btn btn-small" onclick="showHelp('general')">? Help</button>
			</div>
		</div>

		<!-- Game body: three column layout -->
		<div id="game-body">

			<!-- Left: Character/Suspect cards -->
			<div id="character-panel">
				<h3>Suspects</h3>
				<div id="suspect-cards">
					<!-- filled by JS -->
				</div>
			</div>

			<!-- Center: Main phase content -->
			<div id="main-panel">
				<!-- Scene phase, lab phase, or case board content goes here -->
			</div>

			<!-- Right: Evidence sidebar -->
			<div id="evidence-sidebar">
				<h3>Evidence Collected</h3>
				<div id="evidence-list">
					<p class="empty-state">No evidence collected yet.</p>
				</div>
				<div id="lab-results-summary" style="display:none;">
					<h3>Lab Results</h3>
					<div id="results-list"></div>
				</div>
			</div>

		</div>

		<!-- Phase navigation buttons -->
		<div id="phase-nav">
			<button id="btn-to-scene" class="btn btn-nav" onclick="enterScenePhase()" style="display:none;">Crime Scene</button>
			<button id="btn-to-lab" class="btn btn-nav" onclick="enterLabPhase()" style="display:none;">Laboratory</button>
			<button id="btn-to-board" class="btn btn-nav" onclick="enterCaseBoard()" style="display:none;">Case Board</button>
			<button id="btn-end-round" class="btn btn-nav btn-accent" onclick="endRound()" style="display:none;">End Round</button>
		</div>

	</div>

	<!-- ROUND END SCREEN -->
	<div id="round-end-screen" class="screen">
		<div id="round-score-content">
			<!-- filled by JS -->
		</div>
	</div>

	<!-- ACCUSATION SCREEN -->
	<div id="accusation-screen" class="screen">
		<h2>Final Accusation</h2>
		<div id="accusation-content">
			<!-- filled by JS -->
		</div>
	</div>

	<!-- GAME OVER SCREEN -->
	<div id="game-over-screen" class="screen">
		<div id="game-over-content">
			<!-- filled by JS -->
		</div>
	</div>

	<!-- MODAL OVERLAY (for results, dialogs, help) -->
	<div id="modal-overlay" class="modal-hidden">
		<div id="modal-box">
			<button id="modal-close" class="btn btn-small" onclick="closeModal()">&times;</button>
			<div id="modal-content">
				<!-- filled by JS -->
			</div>
		</div>
	</div>

	<!-- Hidden canvas for gel visualization -->
	<canvas id="gel-canvas" width="700" height="450" style="display:none;"></canvas>

</div>
<script>

/* ============================================ */
/* constants.js */
/* ============================================ */

/* ============================================ */
/* SECTION 1: CONSTANTS AND CONFIGURATION       */
/* ============================================ */

// Game phases - state machine states
const PHASE = {
	TITLE: 'TITLE',
	SETUP: 'SETUP',
	INTRO: 'INTRO',
	SCENE: 'SCENE',
	LAB: 'LAB',
	CASE_BOARD: 'CASE_BOARD',
	ROUND_END: 'ROUND_END',
	ACCUSATION: 'ACCUSATION',
	GAME_OVER: 'GAME_OVER'
};

// Difficulty configurations
const DIFFICULTY_CONFIG = {
	easy: {
		label: 'Easy',
		timerSeconds: 300,
		swabsPerRound: 6,
		testsPerRound: 5,
		evidenceQuality: 'pristine',
		description: 'Generous timer, clear evidence, more resources'
	},
	medium: {
		label: 'Medium',
		timerSeconds: 200,
		swabsPerRound: 4,
		testsPerRound: 3,
		evidenceQuality: 'mixed',
		description: 'Moderate timer, some degradation, standard resources'
	},
	hard: {
		label: 'Hard',
		timerSeconds: 120,
		swabsPerRound: 3,
		testsPerRound: 2,
		evidenceQuality: 'degraded',
		description: 'Short timer, degraded samples, limited resources'
	}
};

// CODIS STR loci with realistic allele ranges
const STR_LOCI = {
	'D3S1358': { min: 12, max: 20 },
	'vWA':     { min: 11, max: 24 },
	'FGA':     { min: 17, max: 33 },
	'D8S1179': { min: 7,  max: 19 },
	'D21S11':  { min: 24, max: 38 },
	'D18S51':  { min: 7,  max: 27 },
	'D5S818':  { min: 7,  max: 16 },
	'TH01':    { min: 5,  max: 11 }
};

// Blood type distribution for realistic generation
const BLOOD_TYPES = ['O', 'A', 'B', 'AB'];
const BLOOD_TYPE_WEIGHTS = [0.44, 0.42, 0.10, 0.04];

// Restriction enzymes used in RFLP analysis
const RESTRICTION_ENZYMES = ['EcoRI', 'BamHI', 'HindIII'];

// Evidence types found at crime scenes (only types with compatible tests)
const EVIDENCE_TYPES = ['blood', 'touch_dna', 'saliva'];

// Evidence quality levels
const EVIDENCE_QUALITY = ['pristine', 'degraded', 'mixed', 'trace'];

// Available forensic tests (focused on blood typing and RFLP)
const FORENSIC_TESTS = {
	blood_type: {
		name: 'Blood Typing (ABO/Rh)',
		description: 'Determines blood group using antibody reactions',
		sampleTypes: ['blood'],
		timeMinutes: 5
	},
	rflp: {
		name: 'RFLP Analysis',
		description: 'Restriction Fragment Length Polymorphism - cuts DNA with enzymes and separates by size on a gel',
		sampleTypes: ['blood', 'touch_dna', 'saliva'],
		timeMinutes: 15
	}
};

// Mansion room descriptions for crime scenes
const MANSION_ROOMS = [
	{
		name: 'The Library',
		description: 'A grand room lined with mahogany bookshelves from floor to ceiling. A large desk sits near the window, papers scattered across it. A crystal whiskey decanter sits half-empty on the side table.',
		evidenceLocations: ['on the desk', 'near the doorknob', 'on the carpet by the fireplace', 'on the whiskey glass', 'on the letter opener', 'caught in the window latch']
	},
	{
		name: 'The Study',
		description: 'A private office with leather chairs and a locked safe in the corner. The room smells of pipe tobacco. A chess board mid-game sits between two armchairs.',
		evidenceLocations: ['on the chess piece', 'near the safe dial', 'on the armchair fabric', 'on the tobacco pipe', 'under the desk lamp', 'on the door handle']
	},
	{
		name: 'The Dining Room',
		description: 'A long table set for eight with fine china and silver cutlery. Several wine glasses remain half-full. One chair is knocked over.',
		evidenceLocations: ['on the wine glass rim', 'on the napkin', 'on the overturned chair', 'under the table edge', 'on the silver knife', 'on the tablecloth stain']
	},
	{
		name: 'The Kitchen',
		description: 'A large commercial-style kitchen with copper pots hanging from the ceiling. The back door is ajar. A cutting board has fresh knife marks.',
		evidenceLocations: ['on the knife handle', 'near the back door', 'on the cutting board', 'on the counter edge', 'on the copper pot handle', 'on the towel rack']
	},
	{
		name: 'The Conservatory',
		description: 'A glass-walled garden room filled with exotic plants and wrought iron furniture. The air is humid. A broken flower pot lies on the stone floor.',
		evidenceLocations: ['on the broken pot shard', 'on the iron chair arm', 'on the glass panel', 'among the soil', 'on the watering can', 'on the stone bench']
	},
	{
		name: 'The Master Bedroom',
		description: 'An opulent room with a four-poster bed and heavy velvet curtains. A vanity mirror is cracked. The bedside drawer is open.',
		evidenceLocations: ['on the bedpost', 'on the cracked mirror frame', 'in the open drawer', 'on the curtain pull', 'on the pillow case', 'on the doorframe']
	}
];

// Scoring weights
const SCORE_WEIGHTS = {
	sampleHandling: 10,
	chainOfCustody: 10,
	testSelection: 15,
	controlUsage: 15,
	interpretation: 20,
	conclusionQuality: 20,
	contaminationPenalty: -15,
	overclaimingPenalty: -10,
	efficiencyBonus: 10
};

// Certainty level descriptors for case board
const CERTAINTY_LEVELS = [
	{ value: 'definitive', label: 'Definitive Match', description: 'All markers match with statistical certainty' },
	{ value: 'strong', label: 'Strong Match', description: 'Multiple markers match, high confidence' },
	{ value: 'partial', label: 'Partial Match', description: 'Some markers match, further testing needed' },
	{ value: 'inconclusive', label: 'Inconclusive', description: 'Results do not support a conclusion' },
	{ value: 'exclusion', label: 'Exclusion', description: 'Profile does not match this individual' },
	{ value: 'mixture', label: 'Mixture Detected', description: 'Multiple contributors present in sample' }
];

// mtDNA haplotype identifiers
const MTDNA_HAPLOTYPES = [
	'H1a1', 'H2a1', 'H3a1', 'J1c1', 'J2a1',
	'K1a1', 'K2a1', 'T1a1', 'T2b1', 'U5a1',
	'V1a1', 'W1a1', 'X2a1', 'I1a1', 'L3e1'
];

// Hair types for physical evidence
const HAIR_TYPES = [
	'straight dark brown', 'wavy auburn', 'curly black',
	'straight blonde', 'wavy gray', 'straight red',
	'curly brown', 'wavy dark brown'
];

/* ============================================ */
/* characters.js */
/* ============================================ */

/* ============================================ */
/* SECTION 2: CHARACTER DEFINITIONS             */
/* ============================================ */

// Victim character - always present in every game
var VICTIM_CHARACTER = {
	id: 'victor_graves',
	name: 'Dr. Victor Graves',
	age: 65,
	role: 'Wealthy criminologist and dinner party host',
	alibi: 'Found dead in the mansion',
	motive: '',
	alive: false,
	isKiller: false,
	isVictim: true,
	bloodType: 'A',
	strProfile: {
		'D3S1358': [15, 17],
		'vWA':     [16, 18],
		'FGA':     [21, 24],
		'D8S1179': [12, 14],
		'D21S11':  [29, 31],
		'D18S51':  [14, 18],
		'D5S818':  [11, 13],
		'TH01':    [7, 9]
	},
	rflpFragments: {
		'EcoRI':   [1200, 2800, 4500, 7200],
		'BamHI':   [900, 3100, 5600, 8400],
		'HindIII': [1500, 3400, 6100]
	},
	mtDNAHaplotype: 'H1a1',
	hairType: 'wavy gray',
	shoeSize: 10
};

// Suspect pool - 6 characters for the player to choose 4-6 from
var CHARACTER_POOL = [
	{
		id: 'ted_bundy',
		name: 'Ted Bundy',
		age: 33,
		role: 'Charming law student with a dark side',
		alibi: 'Claims he was in the library reading case law',
		motive: 'Dr. Graves was about to publish a psychological profile that would expose his true nature',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'O',
		strProfile: {
			'D3S1358': [14, 16],
			'vWA':     [17, 19],
			'FGA':     [22, 25],
			'D8S1179': [10, 13],
			'D21S11':  [28, 30],
			'D18S51':  [12, 16],
			'D5S818':  [10, 12],
			'TH01':    [6, 8]
		},
		rflpFragments: {
			'EcoRI':   [1050, 2600, 5100, 7800],
			'BamHI':   [750, 2900, 4800],
			'HindIII': [1800, 3900, 5500, 8200]
		},
		mtDNAHaplotype: 'J1c1',
		hairType: 'straight dark brown',
		shoeSize: 11
	},
	{
		id: 'john_wayne_gacy',
		name: 'John Wayne Gacy',
		age: 37,
		role: 'Jovial entertainer who performs as a clown',
		alibi: 'Claims he was performing card tricks in the parlor for other guests',
		motive: 'Dr. Graves discovered evidence linking him to disappearances in his neighborhood',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'A',
		strProfile: {
			'D3S1358': [13, 18],
			'vWA':     [14, 20],
			'FGA':     [19, 27],
			'D8S1179': [8, 15],
			'D21S11':  [25, 33],
			'D18S51':  [9, 21],
			'D5S818':  [8, 14],
			'TH01':    [5, 10]
		},
		rflpFragments: {
			'EcoRI':   [1400, 3200, 6000, 8900, 9800],
			'BamHI':   [1100, 2500, 5200, 7600],
			'HindIII': [2000, 4200, 7000]
		},
		mtDNAHaplotype: 'K1a1',
		hairType: 'curly black',
		shoeSize: 10
	},
	{
		id: 'jack_the_ripper',
		name: 'Jack the Ripper',
		age: 45,
		role: 'Mysterious surgeon with impeccable manners',
		alibi: 'Claims he was examining the wine cellar collection',
		motive: 'Dr. Graves claimed to have identified the Ripper and planned a public reveal',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'B',
		strProfile: {
			'D3S1358': [16, 19],
			'vWA':     [12, 22],
			'FGA':     [18, 30],
			'D8S1179': [11, 17],
			'D21S11':  [26, 35],
			'D18S51':  [10, 24],
			'D5S818':  [9, 15],
			'TH01':    [7, 11]
		},
		rflpFragments: {
			'EcoRI':   [800, 2100, 4800, 6500],
			'BamHI':   [1300, 3600, 6300, 9100],
			'HindIII': [1100, 2800, 5000, 7400, 9500]
		},
		mtDNAHaplotype: 'T1a1',
		hairType: 'straight blonde',
		shoeSize: 9
	},
	{
		id: 'charles_manson',
		name: 'Charles Manson',
		age: 40,
		role: 'Charismatic cult leader with a wild stare',
		alibi: 'Claims he was meditating in the garden under the moonlight',
		motive: 'Dr. Graves testified against his followers and had him placed on a watchlist',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'O',
		strProfile: {
			'D3S1358': [12, 20],
			'vWA':     [15, 23],
			'FGA':     [20, 28],
			'D8S1179': [9, 16],
			'D21S11':  [27, 36],
			'D18S51':  [11, 19],
			'D5S818':  [7, 11],
			'TH01':    [8, 10]
		},
		rflpFragments: {
			'EcoRI':   [950, 3500, 5800],
			'BamHI':   [1600, 4100, 7300, 9600],
			'HindIII': [1700, 3200, 5900, 8600]
		},
		mtDNAHaplotype: 'U5a1',
		hairType: 'wavy auburn',
		shoeSize: 8
	},
	{
		id: 'jeffrey_dahmer',
		name: 'Jeffrey Dahmer',
		age: 31,
		role: 'Quiet chemist with unsettling calm',
		alibi: 'Claims he was in the kitchen preparing a special dessert',
		motive: 'Dr. Graves was investigating suspicious chemical purchases traced back to him',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'A',
		strProfile: {
			'D3S1358': [15, 18],
			'vWA':     [13, 21],
			'FGA':     [23, 29],
			'D8S1179': [7, 18],
			'D21S11':  [24, 32],
			'D18S51':  [8, 22],
			'D5S818':  [12, 16],
			'TH01':    [6, 9]
		},
		rflpFragments: {
			'EcoRI':   [1600, 2400, 4200, 6800, 9200],
			'BamHI':   [850, 3800, 5500],
			'HindIII': [2200, 4600, 6700, 8800]
		},
		mtDNAHaplotype: 'V1a1',
		hairType: 'straight red',
		shoeSize: 12
	},
	{
		id: 'aileen_wuornos',
		name: 'Aileen Wuornos',
		age: 35,
		role: 'Highway drifter with a volatile temper',
		alibi: 'Claims she was on the veranda smoking and watching the rain',
		motive: 'Dr. Graves profiled her for the FBI and she blamed him for years in prison',
		alive: true,
		isKiller: false,
		isVictim: false,
		bloodType: 'AB',
		strProfile: {
			'D3S1358': [13, 17],
			'vWA':     [16, 24],
			'FGA':     [17, 26],
			'D8S1179': [13, 19],
			'D21S11':  [30, 38],
			'D18S51':  [15, 27],
			'D5S818':  [10, 13],
			'TH01':    [5, 7]
		},
		rflpFragments: {
			'EcoRI':   [700, 1900, 3700, 5400],
			'BamHI':   [1200, 2700, 4400, 6900, 9400],
			'HindIII': [1400, 3600, 6400]
		},
		mtDNAHaplotype: 'X2a1',
		hairType: 'curly brown',
		shoeSize: 7
	}
];

/* ============================================ */
function deepCopyCharacter(character) {
	/* Create a deep copy of a character object so the
	   original CHARACTER_POOL is never mutated.
	   Returns a new object with all nested structures copied. */
	var copy = {};
	var keys = Object.keys(character);
	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		var val = character[key];
		if (val === null || val === undefined) {
			copy[key] = val;
		} else if (Array.isArray(val)) {
			// Shallow copy arrays (allele pairs are arrays of numbers)
			copy[key] = val.slice();
		} else if (typeof val === 'object') {
			// Deep copy nested objects (strProfile, rflpFragments)
			copy[key] = {};
			var innerKeys = Object.keys(val);
			for (var j = 0; j < innerKeys.length; j++) {
				var innerVal = val[innerKeys[j]];
				if (Array.isArray(innerVal)) {
					copy[key][innerKeys[j]] = innerVal.slice();
				} else {
					copy[key][innerKeys[j]] = innerVal;
				}
			}
		} else {
			copy[key] = val;
		}
	}
	return copy;
}

/* ============================================ */
function initializeCharacters(selectedSuspectIds) {
	/* Set up characters for a new game.
	   Takes an array of suspect ID strings chosen by the player.
	   Deep-copies characters from the pool, randomly selects one as
	   the killer, and populates all gameState character fields. */

	// Deep copy the victim
	gameState.victim = deepCopyCharacter(VICTIM_CHARACTER);

	// Deep copy selected suspects from the pool
	var selectedSuspects = [];
	for (var i = 0; i < selectedSuspectIds.length; i++) {
		var suspectId = selectedSuspectIds[i];
		for (var j = 0; j < CHARACTER_POOL.length; j++) {
			if (CHARACTER_POOL[j].id === suspectId) {
				selectedSuspects.push(deepCopyCharacter(CHARACTER_POOL[j]));
				break;
			}
		}
	}

	// Randomly pick one suspect as the killer
	var killerIndex = Math.floor(Math.random() * selectedSuspects.length);
	selectedSuspects[killerIndex].isKiller = true;

	// Store in game state
	gameState.suspects = selectedSuspects;
	gameState.killer = selectedSuspects[killerIndex];
	gameState.deadCharacters = [gameState.victim];

	// Build allCharacters list: victim first, then all suspects
	gameState.allCharacters = [gameState.victim];
	for (var k = 0; k < selectedSuspects.length; k++) {
		gameState.allCharacters.push(selectedSuspects[k]);
	}

	// Initialize suspect notes for case board
	gameState.suspectNotes = {};
	for (var m = 0; m < selectedSuspects.length; m++) {
		gameState.suspectNotes[selectedSuspects[m].id] = '';
	}
}

/* ============================================ */
/* data_generation.js */
/* ============================================ */

/* ============================================ */
/* SECTION 3: DATA GENERATION AND EVIDENCE      */
/* ============================================ */

// Counter for generating unique sample IDs
var _sampleIdCounter = 0;

/* ============================================ */
function generateSampleId() {
	/* Generate a unique evidence sample ID string.
	   Uses an incrementing counter combined with a random suffix. */
	_sampleIdCounter++;
	var randomPart = Math.floor(Math.random() * 9000) + 1000;
	return 'EVD-' + _sampleIdCounter + '-' + randomPart;
}

/* ============================================ */
function pickRandom(arr) {
	/* Return a random element from an array. */
	return arr[Math.floor(Math.random() * arr.length)];
}

/* ============================================ */
function shuffleArray(arr) {
	/* Fisher-Yates shuffle of an array in place. Returns the array. */
	for (var i = arr.length - 1; i > 0; i--) {
		var j = Math.floor(Math.random() * (i + 1));
		var temp = arr[i];
		arr[i] = arr[j];
		arr[j] = temp;
	}
	return arr;
}

/* ============================================ */
function selectEvidenceQuality() {
	/* Select an evidence quality level based on the current difficulty.
	   Easy = mostly pristine, Medium = mixed, Hard = degraded/trace. */
	var difficulty = gameState.difficulty;
	var roll = Math.random();

	if (difficulty === 'easy') {
		// 70% pristine, 20% degraded, 10% mixed
		if (roll < 0.70) { return 'pristine'; }
		if (roll < 0.90) { return 'degraded'; }
		return 'mixed';
	}
	if (difficulty === 'medium') {
		// 30% pristine, 30% degraded, 30% mixed, 10% trace
		if (roll < 0.30) { return 'pristine'; }
		if (roll < 0.60) { return 'degraded'; }
		if (roll < 0.90) { return 'mixed'; }
		return 'trace';
	}
	// hard
	// 10% pristine, 30% degraded, 35% mixed, 25% trace
	if (roll < 0.10) { return 'pristine'; }
	if (roll < 0.40) { return 'degraded'; }
	if (roll < 0.75) { return 'mixed'; }
	return 'trace';
}

/* ============================================ */
function generateEvidenceItem(sourceCharacterId, type, location, quality) {
	/* Create a single evidence sample object.
	   Args:
	     sourceCharacterId: ID of the character this evidence came from
	     type: one of EVIDENCE_TYPES (blood, touch_dna, hair, saliva, fiber)
	     location: description of where in the room it was found
	     quality: one of EVIDENCE_QUALITY (pristine, degraded, mixed, trace)
	   Returns an evidence object ready for collection. */
	var item = {
		id: generateSampleId(),
		type: type,
		location: location,
		quality: quality,
		contaminated: false,
		labeled: false,
		chainOfCustody: false,
		sourceCharacter: sourceCharacterId,
		mixedWith: null,
		collected: false
	};
	return item;
}

/* ============================================ */
function selectInnocentSuspects(count) {
	/* Pick a number of living non-killer suspects to leave trace evidence.
	   Returns an array of suspect objects. */
	var innocents = [];
	for (var i = 0; i < gameState.suspects.length; i++) {
		var s = gameState.suspects[i];
		if (s.alive && !s.isKiller) {
			innocents.push(s);
		}
	}
	shuffleArray(innocents);
	// Return up to count suspects
	var result = [];
	for (var j = 0; j < Math.min(count, innocents.length); j++) {
		result.push(innocents[j]);
	}
	return result;
}

/* ============================================ */
function generateScene(roundNumber) {
	/* Generate a full crime scene for the given round number.
	   Round 1 always uses 'The Library'. Subsequent rounds pick
	   from rooms not yet used. Generates 4-7 evidence items
	   that always include the killer's DNA, victim DNA, and
	   1-2 innocent suspect traces.
	   Returns: { room, evidenceItems, narrative } */

	// Select a room: round 1 is always The Library
	var room = null;
	if (roundNumber === 1) {
		for (var r = 0; r < MANSION_ROOMS.length; r++) {
			if (MANSION_ROOMS[r].name === 'The Library') {
				room = MANSION_ROOMS[r];
				break;
			}
		}
	}
	// Fallback or later rounds: pick a random room
	if (!room) {
		// Collect rooms used in previous rounds to avoid repeats
		var usedRooms = {};
		for (var h = 0; h < gameState.roundHistory.length; h++) {
			var prevScene = gameState.roundHistory[h].scene;
			if (prevScene && prevScene.room) {
				usedRooms[prevScene.room.name] = true;
			}
		}
		var availableRooms = [];
		for (var a = 0; a < MANSION_ROOMS.length; a++) {
			if (!usedRooms[MANSION_ROOMS[a].name]) {
				availableRooms.push(MANSION_ROOMS[a]);
			}
		}
		// If all rooms used, allow repeats
		if (availableRooms.length === 0) {
			availableRooms = MANSION_ROOMS.slice();
		}
		room = pickRandom(availableRooms);
	}

	var evidenceItems = [];
	var locations = room.evidenceLocations.slice();
	shuffleArray(locations);
	var locationIndex = 0;

	// Determine how many evidence items (4-7)
	var itemCount = 4 + Math.floor(Math.random() * 4);
	// Make sure we do not exceed available locations
	if (itemCount > locations.length) {
		itemCount = locations.length;
	}

	// 1) Always include killer DNA evidence (blood or touch_dna)
	var killerTypes = ['blood', 'touch_dna', 'saliva'];
	var killerEvidenceType = pickRandom(killerTypes);
	var killerQuality = selectEvidenceQuality();
	// On easy mode, killer evidence is always at least degraded (never trace)
	if (gameState.difficulty === 'easy' && killerQuality === 'trace') {
		killerQuality = 'degraded';
	}
	evidenceItems.push(
		generateEvidenceItem(
			gameState.killer.id,
			killerEvidenceType,
			locations[locationIndex],
			killerQuality
		)
	);
	locationIndex++;

	// 2) Always include victim DNA (the victim is Dr. Graves)
	var victimTypes = ['blood', 'saliva'];
	evidenceItems.push(
		generateEvidenceItem(
			gameState.victim.id,
			pickRandom(victimTypes),
			locations[locationIndex],
			'pristine'
		)
	);
	locationIndex++;

	// 3) Add 1-2 innocent suspect traces
	var innocentCount = 1 + Math.floor(Math.random() * 2);
	var innocentSuspects = selectInnocentSuspects(innocentCount);
	for (var n = 0; n < innocentSuspects.length; n++) {
		if (locationIndex >= locations.length) { break; }
		var innocentType = pickRandom(EVIDENCE_TYPES);
		var innocentQuality = selectEvidenceQuality();
		var innocentItem = generateEvidenceItem(
			innocentSuspects[n].id,
			innocentType,
			locations[locationIndex],
			innocentQuality
		);
		// On harder difficulties, some innocent evidence may be mixed with killer
		if (gameState.difficulty === 'hard' && Math.random() < 0.3) {
			innocentItem.quality = 'mixed';
			innocentItem.mixedWith = gameState.killer.id;
		}
		evidenceItems.push(innocentItem);
		locationIndex++;
	}

	// 4) Fill remaining slots with assorted evidence
	while (evidenceItems.length < itemCount && locationIndex < locations.length) {
		// Pick a random source: killer, victim, or an innocent suspect
		var sourcePool = [gameState.killer.id, gameState.victim.id];
		for (var p = 0; p < innocentSuspects.length; p++) {
			sourcePool.push(innocentSuspects[p].id);
		}
		var source = pickRandom(sourcePool);
		var fillerType = pickRandom(EVIDENCE_TYPES);
		var fillerQuality = selectEvidenceQuality();
		evidenceItems.push(
			generateEvidenceItem(
				source,
				fillerType,
				locations[locationIndex],
				fillerQuality
			)
		);
		locationIndex++;
	}

	// Shuffle evidence order so killer's is not always first
	shuffleArray(evidenceItems);

	// Build the narrative text for this scene
	var latestVictimName = 'Dr. Victor Graves';
	if (roundNumber > 1 && gameState.deadCharacters.length > 1) {
		// Latest dead character (most recent victim)
		latestVictimName = gameState.deadCharacters[gameState.deadCharacters.length - 1].name;
	}

	var narrative = '';
	if (roundNumber === 1) {
		narrative += 'You arrive at the Graves mansion to find Dr. Victor Graves ';
		narrative += 'dead in ' + room.name + '. ';
		narrative += room.description + ' ';
		narrative += 'The room shows signs of a struggle. ';
		narrative += 'As the forensic investigator, you must carefully ';
		narrative += 'collect and analyze the evidence to identify the killer ';
		narrative += 'among the dinner party guests.';
	} else {
		narrative += 'The killer has struck again! ' + latestVictimName;
		narrative += ' has been found dead in ' + room.name + '. ';
		narrative += room.description + ' ';
		narrative += 'Time is running out. Examine the new crime scene ';
		narrative += 'and gather more evidence before another guest falls.';
	}

	var scene = {
		room: room,
		evidenceItems: evidenceItems,
		narrative: narrative
	};
	return scene;
}

/* ============================================ */
function getCharacterDNA(characterId) {
	/* Look up a character's full DNA profile from gameState.allCharacters.
	   Returns the character object, or null if not found. */
	for (var i = 0; i < gameState.allCharacters.length; i++) {
		if (gameState.allCharacters[i].id === characterId) {
			return gameState.allCharacters[i];
		}
	}
	return null;
}

/* ============================================ */
function generateBloodTypeResult(sample) {
	/* Generate a blood typing result for a collected sample.
	   Returns an object with the blood type and agglutination reactions
	   for anti-A, anti-B, and anti-D (Rh) reagents.
	   Trace quality samples may give no result. */

	// Trace quality: cannot determine blood type
	if (sample.quality === 'trace') {
		return {
			bloodType: 'Indeterminate',
			agglutination: { antiA: 'N/A', antiB: 'N/A', antiD: 'N/A' }
		};
	}

	var character = getCharacterDNA(sample.sourceCharacter);
	if (!character) {
		return {
			bloodType: 'Unknown',
			agglutination: { antiA: false, antiB: false, antiD: false }
		};
	}

	// Determine Rh factor (positive by default for simplicity)
	// Assign based on blood type letter distribution
	var rhPositive = true;
	// About 15% of population is Rh-negative
	if (character.id === 'jack_the_ripper' || character.id === 'aileen_wuornos') {
		rhPositive = false;
	}

	var bt = character.bloodType;
	var antiA = (bt === 'A' || bt === 'AB');
	var antiB = (bt === 'B' || bt === 'AB');

	return {
		bloodType: bt,
		rhFactor: rhPositive,
		agglutination: {
			antiA: antiA,
			antiB: antiB,
			antiD: rhPositive
		}
	};
}

/* ============================================ */
function generateRFLPResult(sample) {
	/* Generate RFLP gel electrophoresis results for a sample.
	   Picks a random enzyme and returns its fragment pattern.
	   Degraded samples may lose some bands.
	   Mixed samples combine fragments from two sources.
	   Returns: {enzyme, fragments} for the selected enzyme. */

	var character = getCharacterDNA(sample.sourceCharacter);
	if (!character) {
		return { enzyme: 'EcoRI', fragments: [], error: 'Unknown source' };
	}

	// Pick a random enzyme for this RFLP run
	var enzyme = RESTRICTION_ENZYMES[Math.floor(Math.random() * RESTRICTION_ENZYMES.length)];
	var fragments = character.rflpFragments[enzyme].slice();

	// Degraded: randomly remove 1-2 bands
	if (sample.quality === 'degraded' || sample.quality === 'trace') {
		var bandsToRemove = 1 + Math.floor(Math.random() * 2);
		for (var d = 0; d < bandsToRemove && fragments.length > 1; d++) {
			var removeIdx = Math.floor(Math.random() * fragments.length);
			fragments.splice(removeIdx, 1);
		}
	}

	// Trace: may fail entirely
	if (sample.quality === 'trace' && Math.random() < 0.4) {
		fragments = [];
	}

	// Mixed: combine with another character's fragments
	if (sample.quality === 'mixed' && sample.mixedWith) {
		var mixedChar = getCharacterDNA(sample.mixedWith);
		if (mixedChar && mixedChar.rflpFragments[enzyme]) {
			var mixedFrags = mixedChar.rflpFragments[enzyme].slice();
			for (var m = 0; m < mixedFrags.length; m++) {
				fragments.push(mixedFrags[m]);
			}
			// Remove duplicates and sort
			var uniqueMap = {};
			for (var u = 0; u < fragments.length; u++) {
				uniqueMap[fragments[u]] = true;
			}
			fragments = [];
			var fragKeys = Object.keys(uniqueMap);
			for (var f = 0; f < fragKeys.length; f++) {
				fragments.push(parseInt(fragKeys[f], 10));
			}
		}
	}

	// Sort fragments by size (ascending for gel display: small = far)
	fragments.sort(function(a, b) { return a - b; });

	return { enzyme: enzyme, fragments: fragments };
}

/* ============================================ */
function generateSTRResult(sample) {
	/* Generate PCR/STR profiling results for a sample.
	   Returns allele pairs for each CODIS locus.
	   Degraded samples may have locus dropout.
	   Mixed samples show extra alleles. */

	var character = getCharacterDNA(sample.sourceCharacter);
	if (!character) {
		return { loci: {}, error: 'Unknown source' };
	}

	var loci = {};
	var locusNames = Object.keys(STR_LOCI);

	for (var i = 0; i < locusNames.length; i++) {
		var locus = locusNames[i];
		var alleles = character.strProfile[locus].slice();

		// Degraded/trace: chance of locus dropout
		if (sample.quality === 'degraded' && Math.random() < 0.2) {
			alleles = [];
			continue;
		}
		if (sample.quality === 'trace' && Math.random() < 0.5) {
			alleles = [];
			continue;
		}

		// Mixed: add alleles from the mixed source
		if (sample.quality === 'mixed' && sample.mixedWith) {
			var mixedChar = getCharacterDNA(sample.mixedWith);
			if (mixedChar && mixedChar.strProfile[locus]) {
				var mixedAlleles = mixedChar.strProfile[locus].slice();
				for (var j = 0; j < mixedAlleles.length; j++) {
					alleles.push(mixedAlleles[j]);
				}
				// Remove duplicate allele values
				var seen = {};
				var unique = [];
				for (var k = 0; k < alleles.length; k++) {
					if (!seen[alleles[k]]) {
						seen[alleles[k]] = true;
						unique.push(alleles[k]);
					}
				}
				alleles = unique;
			}
		}

		// Sort alleles ascending
		alleles.sort(function(a, b) { return a - b; });
		loci[locus] = alleles;
	}

	return { strProfile: loci };
}

/* ============================================ */
function generateMtDNAResult(sample) {
	/* Generate mitochondrial DNA analysis result.
	   Returns the haplotype identifier for the sample source.
	   Trace quality has a chance of failure. */

	// Trace: 30% chance of failure
	if (sample.quality === 'trace' && Math.random() < 0.3) {
		return { haplotype: 'Indeterminate', degraded: true };
	}

	var character = getCharacterDNA(sample.sourceCharacter);
	if (!character) {
		return { haplotype: 'Unknown', degraded: false };
	}

	// Mixed samples: mtDNA shows primary contributor only
	// (mtDNA from hair/bone typically shows one haplotype)
	return {
		haplotype: character.mtDNAHaplotype,
		degraded: false
	};
}

/* ============================================ */
function generateRestrictionResult(sample, enzyme) {
	/* Generate restriction enzyme digest results for a specific enzyme.
	   Returns the fragment pattern for that single enzyme.
	   Handles degradation and mixing same as RFLP. */

	var character = getCharacterDNA(sample.sourceCharacter);
	if (!character) {
		return { enzyme: enzyme, fragments: [], error: 'Unknown source' };
	}

	// Check the enzyme is valid
	if (!character.rflpFragments[enzyme]) {
		return { enzyme: enzyme, fragments: [], error: 'No data for enzyme' };
	}

	var fragments = character.rflpFragments[enzyme].slice();

	// Degraded: remove 1 band
	if (sample.quality === 'degraded' || sample.quality === 'trace') {
		if (fragments.length > 1) {
			var removeIdx = Math.floor(Math.random() * fragments.length);
			fragments.splice(removeIdx, 1);
		}
	}

	// Trace: chance of complete failure
	if (sample.quality === 'trace' && Math.random() < 0.4) {
		return { enzyme: enzyme, fragments: [], note: 'Insufficient DNA' };
	}

	// Mixed: add other source's fragments for this enzyme
	if (sample.quality === 'mixed' && sample.mixedWith) {
		var mixedChar = getCharacterDNA(sample.mixedWith);
		if (mixedChar && mixedChar.rflpFragments[enzyme]) {
			var extras = mixedChar.rflpFragments[enzyme].slice();
			for (var i = 0; i < extras.length; i++) {
				fragments.push(extras[i]);
			}
			// Deduplicate
			var uniqueMap = {};
			for (var u = 0; u < fragments.length; u++) {
				uniqueMap[fragments[u]] = true;
			}
			fragments = [];
			var keys = Object.keys(uniqueMap);
			for (var f = 0; f < keys.length; f++) {
				fragments.push(parseInt(keys[f], 10));
			}
		}
	}

	fragments.sort(function(a, b) { return a - b; });
	return { enzyme: enzyme, fragments: fragments };
}

/* ============================================ */
function buildSuspectReferenceProfiles(testType, enzyme) {
	/* Build reference fragment profiles for all alive suspects.
	   Used for gel comparison lanes in RFLP and restriction tests.
	   Args:
	     testType: 'rflp' or 'restriction'
	     enzyme: restriction enzyme name (e.g. 'EcoRI')
	   Returns: object mapping suspect IDs to fragment arrays. */

	var profiles = {};
	var aliveSuspects = getAliveSuspects();
	for (var i = 0; i < aliveSuspects.length; i++) {
		var suspect = aliveSuspects[i];
		var dna = getCharacterDNA(suspect.id);
		if (dna && dna.rflpFragments && dna.rflpFragments[enzyme]) {
			profiles[suspect.id] = dna.rflpFragments[enzyme].slice();
			profiles[suspect.id].sort(function(a, b) { return a - b; });
		}
	}
	return profiles;
}

/* ============================================ */
function generateControlFragments(testType, enzyme) {
	/* Generate control lane fragments for gel-based tests.
	   Returns a standard size marker ladder. */
	// Standard DNA size marker ladder
	return [500, 1000, 2000, 3000, 4000, 5000, 6000, 8000, 10000];
}

/* ============================================ */
function buildSuspectSTRProfiles() {
	/* Build STR reference profiles for all alive suspects.
	   Returns: object mapping suspect IDs to STR profile objects. */

	var profiles = {};
	var aliveSuspects = getAliveSuspects();
	for (var i = 0; i < aliveSuspects.length; i++) {
		var suspect = aliveSuspects[i];
		var dna = getCharacterDNA(suspect.id);
		if (dna && dna.strProfile) {
			profiles[suspect.id] = dna.strProfile;
		}
	}
	return profiles;
}

/* ============================================ */
function generateTestResult(sample, testType, includeControl) {
	/* Generate result data for running a forensic test on a sample.
	   Dispatches to the appropriate test-specific generator.
	   Args:
	     sample: a collected evidence item object
	     testType: string key from FORENSIC_TESTS (blood_type, rflp, str, mtdna, restriction)
	     includeControl: boolean, whether a control sample was run alongside
	   Returns a result object with test-specific data and metadata. */

	var result = {
		sampleId: sample.id,
		testType: testType,
		testName: FORENSIC_TESTS[testType] ? FORENSIC_TESTS[testType].name : testType,
		timestamp: Date.now(),
		controlIncluded: includeControl || false,
		sampleQuality: sample.quality,
		contaminated: sample.contaminated,
		data: null
	};

	// Check sample type compatibility
	var testConfig = FORENSIC_TESTS[testType];
	if (testConfig) {
		var compatible = false;
		for (var i = 0; i < testConfig.sampleTypes.length; i++) {
			if (testConfig.sampleTypes[i] === (sample.actualType || sample.type)) {
				compatible = true;
				break;
			}
		}
		if (!compatible) {
			result.data = { error: 'Incompatible sample type for this test' };
			result.success = false;
			return result;
		}
	}

	// Contaminated samples produce unreliable results
	if (sample.contaminated) {
		result.data = { warning: 'Sample was contaminated during collection' };
		result.reliable = false;
	}

	// Dispatch to specific test generator and merge data onto result
	var testData = null;
	switch (testType) {
		case 'blood_type':
			testData = generateBloodTypeResult(sample);
			break;
		case 'rflp':
			testData = generateRFLPResult(sample);
			break;
		case 'str':
			testData = generateSTRResult(sample);
			break;
		case 'mtdna':
			testData = generateMtDNAResult(sample);
			break;
		case 'restriction':
			// Default to first enzyme if none specified
			testData = generateRestrictionResult(sample, 'EcoRI');
			break;
		default:
			result.error = 'Unknown test type: ' + testType;
			result.success = false;
			return result;
	}

	// Merge test-specific data directly onto the result object
	// so display functions can read result.bloodType, result.fragments, etc.
	if (testData) {
		var dataKeys = Object.keys(testData);
		for (var k = 0; k < dataKeys.length; k++) {
			result[dataKeys[k]] = testData[dataKeys[k]];
		}
	}

	result.success = true;

	// For gel-based tests (RFLP, restriction), add suspect reference profiles
	// so the player can visually compare evidence against each suspect
	if (testType === 'rflp' || testType === 'restriction') {
		result.suspectProfiles = buildSuspectReferenceProfiles(testType, result.enzyme);

		// Add control fragments if control was included
		if (includeControl) {
			result.controlFragments = generateControlFragments(testType, result.enzyme);
		}
	}

	// For STR tests, add suspect reference profiles for comparison
	if (testType === 'str') {
		result.suspectStrProfiles = buildSuspectSTRProfiles();
	}

	// Add control result if included
	if (includeControl) {
		result.controlResult = {
			status: 'passed',
			note: 'Positive and negative controls behaved as expected'
		};
	}

	return result;
}

/* ============================================ */
/* game_state.js */
/* ============================================ */

/* ============================================ */
/* SECTION 4: GAME STATE MACHINE                */
/* ============================================ */

// Global game state - read/written by all modules
let gameState = {
	// Current phase
	phase: PHASE.TITLE,
	difficulty: 'medium',
	round: 1,
	maxRounds: 10,

	// Characters
	victim: null,
	suspects: [],
	killer: null,
	deadCharacters: [],
	allCharacters: [],

	// Current round state
	currentScene: null,
	availableEvidence: [],
	collectedSamples: [],
	swabsRemaining: 0,
	glovesOn: false,
	contaminationEvents: 0,

	// Lab state
	testsRemaining: 0,
	testResults: [],
	currentTestResult: null,

	// Case board state
	suspectNotes: {},
	currentConclusion: '',
	accusationMade: false,
	accusedSuspect: null,

	// Scoring
	totalScore: 0,
	roundScores: [],
	currentRoundScore: {
		sampleHandling: 0,
		chainOfCustody: 0,
		testSelection: 0,
		controlUsage: 0,
		interpretation: 0,
		conclusionQuality: 0,
		contaminationPenalty: 0,
		overclaimingPenalty: 0,
		efficiencyBonus: 0
	},

	// Timer
	timerSeconds: 0,
	timerMax: 0,
	timerRunning: false,
	timerInterval: null,

	// Game history
	roundHistory: [],
	evidenceLog: [],

	// Flags
	gameStarted: false,
	gameOver: false,
	tutorialShown: false
};

/* ============================================ */
function resetGameState() {
	/* Reset game state for a new game. */
	gameState.phase = PHASE.TITLE;
	gameState.round = 1;
	gameState.victim = null;
	gameState.suspects = [];
	gameState.killer = null;
	gameState.deadCharacters = [];
	gameState.allCharacters = [];
	gameState.currentScene = null;
	gameState.availableEvidence = [];
	gameState.collectedSamples = [];
	gameState.swabsRemaining = 0;
	gameState.glovesOn = false;
	gameState.contaminationEvents = 0;
	gameState.testsRemaining = 0;
	gameState.testResults = [];
	gameState.currentTestResult = null;
	gameState.suspectNotes = {};
	gameState.currentConclusion = '';
	gameState.accusationMade = false;
	gameState.accusedSuspect = null;
	gameState.totalScore = 0;
	gameState.roundScores = [];
	gameState.currentRoundScore = {
		sampleHandling: 0,
		chainOfCustody: 0,
		testSelection: 0,
		controlUsage: 0,
		interpretation: 0,
		conclusionQuality: 0,
		contaminationPenalty: 0,
		overclaimingPenalty: 0,
		efficiencyBonus: 0
	};
	gameState.timerSeconds = 0;
	gameState.timerMax = 0;
	gameState.timerRunning = false;
	if (gameState.timerInterval) {
		clearInterval(gameState.timerInterval);
	}
	gameState.timerInterval = null;
	gameState.roundHistory = [];
	gameState.evidenceLog = [];
	gameState.gameStarted = false;
	gameState.gameOver = false;
	gameState.tutorialShown = false;
}

/* ============================================ */
function resetRoundState() {
	/* Reset state for a new round within the same game. */
	gameState.currentScene = null;
	gameState.availableEvidence = [];
	gameState.collectedSamples = [];
	gameState.swabsRemaining = DIFFICULTY_CONFIG[gameState.difficulty].swabsPerRound;
	gameState.glovesOn = false;
	gameState.contaminationEvents = 0;
	gameState.testsRemaining = DIFFICULTY_CONFIG[gameState.difficulty].testsPerRound;
	gameState.currentTestResult = null;
	gameState.currentConclusion = '';
	gameState.currentRoundScore = {
		sampleHandling: 0,
		chainOfCustody: 0,
		testSelection: 0,
		controlUsage: 0,
		interpretation: 0,
		conclusionQuality: 0,
		contaminationPenalty: 0,
		overclaimingPenalty: 0,
		efficiencyBonus: 0
	};
}

/* ============================================ */
function transitionTo(newPhase) {
	/* Transition game state to a new phase and update the UI.
	   Validates transitions and handles phase entry logic. */
	let oldPhase = gameState.phase;
	gameState.phase = newPhase;

	// Stop timer between phases if needed
	if (newPhase === PHASE.ROUND_END || newPhase === PHASE.GAME_OVER || newPhase === PHASE.ACCUSATION) {
		stopTimer();
	}

	// Hide all screens
	let screens = document.querySelectorAll('.screen');
	for (let i = 0; i < screens.length; i++) {
		screens[i].classList.remove('active');
	}

	// Show appropriate screen and render content
	switch (newPhase) {
		case PHASE.TITLE:
			document.getElementById('title-screen').classList.add('active');
			break;

		case PHASE.SETUP:
			document.getElementById('setup-screen').classList.add('active');
			renderSetupScreen();
			break;

		case PHASE.INTRO:
			document.getElementById('intro-screen').classList.add('active');
			renderIntroBriefing();
			break;

		case PHASE.SCENE:
			document.getElementById('game-screen').classList.add('active');
			updatePhaseDisplay('Scene Investigation');
			updatePhaseNav('scene');
			updateSuspectCards();
			updateScoreDisplay();
			updateRoundDisplay();
			renderScenePhase();
			if (!gameState.timerRunning) {
				startTimer(
					DIFFICULTY_CONFIG[gameState.difficulty].timerSeconds,
					onTimerExpired
				);
			}
			break;

		case PHASE.LAB:
			document.getElementById('game-screen').classList.add('active');
			updatePhaseDisplay('Laboratory Analysis');
			updatePhaseNav('lab');
			renderLabPhase();
			break;

		case PHASE.CASE_BOARD:
			document.getElementById('game-screen').classList.add('active');
			updatePhaseDisplay('Case Board');
			updatePhaseNav('board');
			renderCaseBoard();
			break;

		case PHASE.ROUND_END:
			document.getElementById('round-end-screen').classList.add('active');
			renderRoundEnd();
			break;

		case PHASE.ACCUSATION:
			document.getElementById('accusation-screen').classList.add('active');
			renderAccusation();
			break;

		case PHASE.GAME_OVER:
			document.getElementById('game-over-screen').classList.add('active');
			renderGameOver();
			break;
	}
}

/* ============================================ */
function showSetupScreen() {
	/* Transition from title to setup screen. */
	resetGameState();
	transitionTo(PHASE.SETUP);
}

/* ============================================ */
function startCase() {
	/* Validate setup selections and begin the game. */
	let selectedSuspects = getSelectedSuspects();
	if (selectedSuspects.length < 4 || selectedSuspects.length > 6) {
		showModal('Selection Error', '<p>Please select between 4 and 6 suspects.</p>');
		return;
	}

	let difficulty = getSelectedDifficulty();
	gameState.difficulty = difficulty;
	gameState.gameStarted = true;

	// Initialize characters for this game
	initializeCharacters(selectedSuspects);

	// Reset round state before generating scene (resetRoundState clears currentScene)
	resetRoundState();

	// Generate the first crime scene after reset
	gameState.currentScene = generateScene(gameState.round);
	// Populate available evidence from the generated scene
	if (gameState.currentScene && gameState.currentScene.evidenceItems) {
		gameState.availableEvidence = gameState.currentScene.evidenceItems;
	}

	transitionTo(PHASE.INTRO);
}

/* ============================================ */
function enterScenePhase() {
	/* Enter or return to the scene investigation phase. */
	transitionTo(PHASE.SCENE);
}

/* ============================================ */
function enterLabPhase() {
	/* Enter the laboratory analysis phase. */
	if (gameState.collectedSamples.length === 0) {
		showModal('No Samples', '<p>You need to collect at least one evidence sample before running lab tests.</p>');
		return;
	}
	transitionTo(PHASE.LAB);
}

/* ============================================ */
function enterCaseBoard() {
	/* Enter the case board phase. */
	transitionTo(PHASE.CASE_BOARD);
}

/* ============================================ */
function endRound() {
	/* End the current round, calculate score, and advance. */
	stopTimer();
	let roundScore = calculateRoundScore();
	gameState.roundScores.push(roundScore);
	gameState.totalScore += roundScore.total;
	gameState.roundHistory.push({
		round: gameState.round,
		score: roundScore,
		samplesCollected: gameState.collectedSamples.length,
		testsRun: gameState.testResults.length
	});
	transitionTo(PHASE.ROUND_END);
}

/* ============================================ */
function onTimerExpired() {
	/* Called when the round timer hits zero.
	   A suspect dies and the game checks for end conditions. */
	stopTimer();

	// Find a living non-killer suspect to kill
	let aliveSuspects = gameState.suspects.filter(function(s) {
		return s.alive && !s.isKiller;
	});

	if (aliveSuspects.length > 0) {
		// Kill a random living suspect
		let victimIndex = Math.floor(Math.random() * aliveSuspects.length);
		let newVictim = aliveSuspects[victimIndex];
		newVictim.alive = false;
		gameState.deadCharacters.push(newVictim);

		// Count remaining alive suspects (including killer)
		let remaining = gameState.suspects.filter(function(s) {
			return s.alive;
		});

		if (remaining.length <= 2) {
			// Force final accusation
			showModal('Time is up!',
				'<p><strong>' + newVictim.name + '</strong> has been found dead!</p>' +
				'<p>With only ' + remaining.length + ' suspect(s) remaining, you must make your final accusation now.</p>',
				function() {
					closeModal();
					transitionTo(PHASE.ACCUSATION);
				}
			);
		} else {
			// New round with new crime scene
			showModal('Another victim!',
				'<p><strong>' + newVictim.name + '</strong> has been found dead!</p>' +
				'<p>The killer has struck again. A new crime scene awaits investigation.</p>' +
				'<p>Remaining suspects: ' + remaining.length + '</p>',
				function() {
					closeModal();
					advanceToNextRound();
				}
			);
		}
	}
}

/* ============================================ */
function advanceToNextRound() {
	/* Set up and start the next investigation round. */
	// Score current round first
	let roundScore = calculateRoundScore();
	gameState.roundScores.push(roundScore);
	gameState.totalScore += roundScore.total;
	gameState.roundHistory.push({
		round: gameState.round,
		score: roundScore,
		samplesCollected: gameState.collectedSamples.length,
		testsRun: gameState.testResults.length
	});

	gameState.round++;
	resetRoundState();
	gameState.currentScene = generateScene(gameState.round);
	// Populate available evidence from the generated scene
	if (gameState.currentScene && gameState.currentScene.evidenceItems) {
		gameState.availableEvidence = gameState.currentScene.evidenceItems;
	}

	updateRoundDisplay();
	updateScoreDisplay();
	updateSuspectCards();
	transitionTo(PHASE.SCENE);
}

/* ============================================ */
function makeAccusation(suspectId) {
	/* Player accuses a suspect. Check if correct. */
	gameState.accusationMade = true;
	let accused = null;
	for (let i = 0; i < gameState.suspects.length; i++) {
		if (gameState.suspects[i].id === suspectId) {
			accused = gameState.suspects[i];
			break;
		}
	}
	gameState.accusedSuspect = accused;
	gameState.gameOver = true;
	stopTimer();
	transitionTo(PHASE.GAME_OVER);
}

/* ============================================ */
function getAliveSuspects() {
	/* Return array of living suspects. */
	return gameState.suspects.filter(function(s) {
		return s.alive;
	});
}

/* ============================================ */
function getSuspectById(suspectId) {
	/* Find a suspect by their ID string. */
	for (let i = 0; i < gameState.allCharacters.length; i++) {
		if (gameState.allCharacters[i].id === suspectId) {
			return gameState.allCharacters[i];
		}
	}
	return null;
}

/* ============================================ */
/* timer.js */
/* ============================================ */

/* ============================================ */
/* TIMER SYSTEM - Countdown and Display        */
/* ============================================ */

/* ============================================ */
function startTimer(seconds, onExpireCallback) {
	/* Start the countdown timer from the given number of seconds.
	   Updates gameState timer fields and begins a one-second interval
	   that decrements the counter each tick.

	Args:
		seconds: integer number of seconds for the countdown
		onExpireCallback: function called when the timer reaches zero
	*/
	// Store the timer configuration in gameState
	gameState.timerSeconds = seconds;
	gameState.timerMax = seconds;
	gameState.timerRunning = true;

	// Clear any existing interval before starting a new one
	if (gameState.timerInterval) {
		clearInterval(gameState.timerInterval);
	}

	// Render the initial display immediately
	updateTimerDisplay();

	// Start the one-second countdown interval
	gameState.timerInterval = setInterval(function() {
		gameState.timerSeconds--;
		updateTimerDisplay();

		// Check for timer expiration
		if (gameState.timerSeconds <= 0) {
			gameState.timerSeconds = 0;
			stopTimer();
			if (typeof onExpireCallback === 'function') {
				onExpireCallback();
			}
		}
	}, 1000);
}

/* ============================================ */
function stopTimer() {
	/* Stop the timer completely and clear the interval.
	   Resets timerRunning to false but preserves the current
	   timerSeconds value for display purposes. */
	if (gameState.timerInterval) {
		clearInterval(gameState.timerInterval);
		gameState.timerInterval = null;
	}
	gameState.timerRunning = false;
}

/* ============================================ */
function pauseTimer() {
	/* Pause the timer without resetting the remaining seconds.
	   Clears the interval but keeps timerSeconds at its current
	   value so resumeTimer() can pick up where it left off. */
	if (gameState.timerInterval) {
		clearInterval(gameState.timerInterval);
		gameState.timerInterval = null;
	}
	gameState.timerRunning = false;
}

/* ============================================ */
function resumeTimer(onExpireCallback) {
	/* Resume the timer from the current timerSeconds value.
	   Starts a new interval that continues counting down from
	   wherever the timer was paused.

	Args:
		onExpireCallback: function called when the timer reaches zero
	*/
	// Do not resume if there is no time left
	if (gameState.timerSeconds <= 0) {
		return;
	}

	gameState.timerRunning = true;

	// Clear any stale interval just in case
	if (gameState.timerInterval) {
		clearInterval(gameState.timerInterval);
	}

	// Start the countdown from the current remaining value
	gameState.timerInterval = setInterval(function() {
		gameState.timerSeconds--;
		updateTimerDisplay();

		// Check for timer expiration
		if (gameState.timerSeconds <= 0) {
			gameState.timerSeconds = 0;
			stopTimer();
			if (typeof onExpireCallback === 'function') {
				onExpireCallback();
			}
		}
	}, 1000);
}

/* ============================================ */
function updateTimerDisplay() {
	/* Update the visual timer bar and text in the game header.
	   Sets the #timer-bar-fill width as a percentage of time remaining.
	   Sets #timer-text to "M:SS" format.
	   Changes color based on fraction remaining:
	     green (>60%), yellow (30-60%), red (<30%).
	   Adds CSS class 'timer-critical' when <15% and
	   'timer-warning' when <30% for animation triggers. */
	var barFill = document.getElementById('timer-bar-fill');
	var timerText = document.getElementById('timer-text');

	// Guard against missing DOM elements
	if (!barFill || !timerText) {
		return;
	}

	// Calculate the fraction of time remaining
	var fraction = 0;
	if (gameState.timerMax > 0) {
		fraction = gameState.timerSeconds / gameState.timerMax;
	}

	// Clamp fraction to valid range
	if (fraction < 0) {
		fraction = 0;
	}
	if (fraction > 1) {
		fraction = 1;
	}

	// Set the bar width as a percentage
	var widthPercent = Math.round(fraction * 100);
	barFill.style.width = widthPercent + '%';

	// Set the bar color based on remaining time fraction
	var color = getTimerColor(fraction);
	barFill.style.backgroundColor = color;

	// Format the remaining seconds as M:SS
	var totalSeconds = Math.max(0, gameState.timerSeconds);
	var minutes = Math.floor(totalSeconds / 60);
	var seconds = totalSeconds % 60;
	var secondsStr = (seconds < 10) ? '0' + seconds : String(seconds);
	timerText.textContent = minutes + ':' + secondsStr;

	// Apply CSS classes for warning and critical animations
	var timerContainer = document.getElementById('timer-container');
	if (timerContainer) {
		// Remove existing state classes first
		timerContainer.classList.remove('timer-warning');
		timerContainer.classList.remove('timer-critical');

		// Add appropriate class based on fraction remaining
		if (fraction < 0.15) {
			timerContainer.classList.add('timer-critical');
		} else if (fraction < 0.30) {
			timerContainer.classList.add('timer-warning');
		}
	}
}

/* ============================================ */
function getTimerColor(fraction) {
	/* Returns a CSS color string based on the fraction of time remaining.

	Args:
		fraction: number between 0.0 and 1.0 representing time left

	Returns:
		string: hex color code
		  >0.6  -> '#4caf50' (green)
		  0.3-0.6 -> '#ff9800' (yellow/orange)
		  <0.3  -> '#f44336' (red)
	*/
	if (fraction > 0.6) {
		return '#4caf50';
	}
	if (fraction >= 0.3) {
		return '#ff9800';
	}
	return '#f44336';
}

/* ============================================ */
/* scene_phase.js */
/* ============================================ */

/* ============================================ */
/* SECTION 5: SCENE INVESTIGATION PHASE         */
/* ============================================ */

// Descriptive text pools for each evidence type
var EVIDENCE_DESCRIPTIONS = {
	blood: [
		'A dark red stain has soaked into the surface.',
		'Dried blood droplets form a scattered pattern.',
		'A smeared streak of blood, still slightly tacky.',
		'Tiny blood spatter marks dot the area.',
		'A small pool of dried blood has collected here.'
	],
	touch_dna: [
		'Smudged fingerprints are visible on the surface.',
		'Skin cells and oils left behind from a firm grip.',
		'Faint oily residue suggests recent handling.',
		'A visible palm print pressed against the surface.',
		'Latent prints partially visible under angled light.'
	],
	hair: [
		'A single strand of hair lies on the surface.',
		'Several loose hairs are caught in the fabric.',
		'A hair with root attached rests on the edge.',
		'Fine hairs are tangled around the surface.',
		'A distinctive hair strand stands out against the background.'
	],
	saliva: [
		'A wet spot on the rim suggests recent contact.',
		'Dried saliva traces are visible under light.',
		'A faint moisture ring marks where lips touched.',
		'Residue consistent with saliva coats the surface.',
		'A small dried droplet sits on the edge.'
	],
	fiber: [
		'Fabric fibers are caught on the rough edge.',
		'Thread fragments cling to the surface.',
		'A tuft of textile fibers is wedged in the gap.',
		'Loose threads have snagged on the material.',
		'Tiny fiber strands are barely visible without magnification.'
	]
};

// Icon characters for each evidence type (ASCII-safe)
var EVIDENCE_ICONS = {
	blood: '[B]',
	touch_dna: '[D]',
	hair: '[H]',
	saliva: '[S]',
	fiber: '[F]'
};

/* ============================================ */
function renderScenePhase() {
	/*
	Renders the full scene investigation UI into #main-panel.
	Shows the room, narrative, gloves button, swab counter,
	and a grid of clickable evidence cards.
	*/
	var mainPanel = document.getElementById('main-panel');
	var scene = gameState.currentScene;

	// Safety check: bail out if no scene is loaded
	if (!scene) {
		mainPanel.innerHTML = '<p>Error: No crime scene data loaded.</p>';
		return;
	}

	var html = '';

	// -- Scene header: room name and description --
	html += '<div class="scene-header">';
	html += '<h2>' + escapeHtml(scene.room.name) + '</h2>';
	html += '<p class="scene-description">' + escapeHtml(scene.room.description) + '</p>';
	html += '</div>';

	// -- Narrative paragraph about the incident --
	html += '<div class="scene-narrative">';
	html += '<p class="narrative-text">';
	html += buildNarrativeText(scene);
	html += '</p>';
	html += '</div>';

	// -- Controls row: gloves button and swab counter --
	html += '<div class="scene-controls">';
	html += buildGlovesButton();
	html += buildSwabCounter();
	html += '</div>';

	// -- Evidence grid --
	html += '<div class="evidence-grid">';
	var evidence = gameState.availableEvidence;
	for (var i = 0; i < evidence.length; i++) {
		html += buildEvidenceCard(evidence[i], i);
	}
	html += '</div>';

	// Inject into the main panel
	mainPanel.innerHTML = html;

	// Update the evidence sidebar to reflect current state
	updateEvidenceSidebar();
}

/* ============================================ */
function buildNarrativeText(scene) {
	/*
	Constructs a narrative paragraph describing the crime scene.
	Uses the current victim and round information for context.
	*/
	var victimName = 'the victim';
	if (gameState.victim && gameState.victim.name) {
		victimName = escapeHtml(gameState.victim.name);
	}

	// Check if there are additional dead characters this round
	var deadCount = gameState.deadCharacters.length;

	var text = '';
	if (gameState.round === 1) {
		// First round narrative
		text += 'You arrive at the scene where ' + victimName;
		text += ' was found. The room has been cordoned off, ';
		text += 'but time is limited before evidence degrades. ';
		text += 'Look carefully for biological evidence that can ';
		text += 'be collected and analyzed in the lab.';
	} else {
		// Subsequent rounds - the killer has struck again
		var latestVictim = 'another victim';
		if (deadCount > 0) {
			var lastDead = gameState.deadCharacters[deadCount - 1];
			if (lastDead && lastDead.name) {
				latestVictim = escapeHtml(lastDead.name);
			}
		}
		text += 'The killer has struck again. ';
		text += latestVictim + ' was found here under suspicious circumstances. ';
		text += 'This is round ' + gameState.round + ' of the investigation. ';
		text += 'Collect evidence carefully and move to the lab when ready.';
	}

	return text;
}

/* ============================================ */
function buildGlovesButton() {
	/*
	Returns HTML for the gloves toggle button.
	Red outline when gloves are off, green with checkmark when on.
	*/
	var html = '';
	if (gameState.glovesOn) {
		// Gloves are already on - show green confirmation
		html += '<button class="btn btn-gloves gloves-on" disabled>';
		html += '[OK] Gloves On';
		html += '</button>';
	} else {
		// Gloves are off - prominent red warning button
		html += '<button class="btn btn-gloves gloves-off" onclick="putOnGloves()">';
		html += '!! Put On Gloves !!';
		html += '</button>';
	}
	return html;
}

/* ============================================ */
function buildSwabCounter() {
	/*
	Returns HTML displaying how many swabs remain for collection.
	*/
	var remaining = gameState.swabsRemaining;
	var total = DIFFICULTY_CONFIG[gameState.difficulty].swabsPerRound;
	var html = '<div class="swab-counter">';
	html += 'Swabs: <strong>' + remaining + '</strong> / ' + total + ' remaining';
	html += '</div>';
	return html;
}

/* ============================================ */
function buildEvidenceCard(evidenceItem, index) {
	/*
	Builds the HTML for a single evidence card in the grid.
	Grays out cards for already-collected items.
	Args:
		evidenceItem: object with type, location, description, quality, collected
		index: position in the availableEvidence array
	*/
	var isCollected = evidenceItem.collected;
	var cardClass = 'evidence-card';
	if (isCollected) {
		cardClass += ' evidence-collected';
	}

	var html = '';
	if (isCollected) {
		// Disabled card - already collected
		html += '<div class="' + cardClass + '">';
	} else {
		// Clickable card
		html += '<div class="' + cardClass + '" onclick="collectEvidence(' + index + ')">';
	}

	// Evidence type tag with icon
	var typeLabel = evidenceItem.type.replace('_', ' ');
	html += '<div class="evidence-tag tag-' + evidenceItem.type + '">';
	html += EVIDENCE_ICONS[evidenceItem.type] + ' ' + typeLabel.toUpperCase();
	html += '</div>';

	// Location within the room
	html += '<div class="evidence-location">';
	html += escapeHtml(evidenceItem.location);
	html += '</div>';

	// Descriptive text about the evidence
	html += '<div class="evidence-description">';
	html += escapeHtml(evidenceItem.description);
	html += '</div>';

	// Quality indicator
	html += '<div class="evidence-quality">';
	html += 'Quality: ' + evidenceItem.quality;
	html += '</div>';

	// Collected overlay
	if (isCollected) {
		html += '<div class="collected-overlay">COLLECTED</div>';
	}

	html += '</div>';
	return html;
}

/* ============================================ */
function putOnGloves() {
	/*
	Handles the player clicking the Put On Gloves button.
	Sets the glovesOn flag and re-renders the scene.
	*/
	gameState.glovesOn = true;
	renderScenePhase();
}

/* ============================================ */
function collectEvidence(evidenceIndex) {
	/*
	Called when the player clicks an evidence card to collect it.
	Checks for gloves, swab availability, and then opens
	the collection dialog.
	Args:
		evidenceIndex: index into gameState.availableEvidence
	*/
	var evidenceItem = gameState.availableEvidence[evidenceIndex];

	// Guard: item already collected
	if (evidenceItem.collected) {
		return;
	}

	// Check if player has swabs remaining
	if (gameState.swabsRemaining <= 0) {
		showModal(
			'No Swabs Remaining',
			'<p>You have used all your collection swabs for this round.</p>' +
			'<p>Proceed to the Laboratory to analyze what you have, ' +
			'or review your evidence on the Case Board.</p>'
		);
		return;
	}

	// Check for gloves - contamination mechanic
	if (!gameState.glovesOn) {
		// Increment contamination counter
		gameState.contaminationEvents++;

		// Mark this specific evidence item as contaminated
		evidenceItem.contaminated = true;

		// Apply score penalty for contamination
		gameState.currentRoundScore.contaminationPenalty += SCORE_WEIGHTS.contaminationPenalty;

		// Show contamination warning, then proceed with collection
		showModal(
			'WARNING: Contamination!',
			'<p style="color: #cc0000; font-weight: bold;">' +
			'WARNING: You collected evidence without gloves!</p>' +
			'<p>Your bare hands have contaminated the sample. ' +
			'Your own DNA is now mixed with the evidence, ' +
			'which may compromise lab results.</p>' +
			'<p>Contamination events so far: <strong>' +
			gameState.contaminationEvents + '</strong></p>' +
			'<p>Always put on gloves before handling evidence!</p>',
			function() {
				// Proceed to collection dialog despite contamination
				showCollectionDialog(evidenceItem, evidenceIndex);
			}
		);
		return;
	}

	// Normal collection path - gloves on, swabs available
	showCollectionDialog(evidenceItem, evidenceIndex);
}

/* ============================================ */
function showCollectionDialog(evidenceItem, evidenceIndex) {
	/*
	Displays a modal dialog for the player to label their sample.
	Includes fields for sample label, evidence type guess, and notes.
	Args:
		evidenceItem: the evidence object being collected
		evidenceIndex: index in gameState.availableEvidence
	*/
	// Pre-select the evidence type dropdown based on the item
	var guessedType = guessEvidenceType(evidenceItem);

	// Auto-generate a descriptive label
	var typeDisplay = guessedType.replace(/_/g, ' ');
	var autoLabel = typeDisplay.charAt(0).toUpperCase() + typeDisplay.slice(1);
	autoLabel += ' - ' + evidenceItem.location;

	var formHtml = '';
	formHtml += '<div class="collection-form">';

	// Auto-generated sample label (editable)
	formHtml += '<div class="form-group">';
	formHtml += '<label for="sample-label">Sample Label:</label>';
	formHtml += '<input type="text" id="sample-label" ';
	formHtml += 'value="' + escapeHtml(autoLabel) + '" ';
	formHtml += 'maxlength="60">';
	formHtml += '<p class="form-hint">Auto-generated label. Edit if desired.</p>';
	formHtml += '</div>';

	// Evidence type dropdown
	formHtml += '<div class="form-group">';
	formHtml += '<label for="evidence-type-select">Evidence Type:</label>';
	formHtml += '<select id="evidence-type-select">';
	for (var i = 0; i < EVIDENCE_TYPES.length; i++) {
		var evType = EVIDENCE_TYPES[i];
		var evLabel = evType.replace(/_/g, ' ');
		var selected = (evType === guessedType) ? ' selected' : '';
		formHtml += '<option value="' + evType + '"' + selected + '>';
		formHtml += evLabel;
		formHtml += '</option>';
	}
	formHtml += '</select>';
	formHtml += '</div>';

	// Location notes auto-filled
	formHtml += '<div class="form-group">';
	formHtml += '<label for="location-notes">Location Notes:</label>';
	formHtml += '<input type="text" id="location-notes" ';
	formHtml += 'value="' + escapeHtml(evidenceItem.location) + '" ';
	formHtml += 'maxlength="80">';
	formHtml += '</div>';

	// Collect button (prominent)
	formHtml += '<button class="btn btn-primary" ';
	formHtml += 'onclick="submitCollectionForm(' + evidenceIndex + ')">';
	formHtml += 'Collect Sample';
	formHtml += '</button>';

	formHtml += '</div>';

	showModal('Collect Evidence Sample', formHtml);
}

/* ============================================ */
function guessEvidenceType(evidenceItem) {
	/*
	Returns the evidence type. Uses the item's type field directly since
	evidence items are generated with a known type. Falls back to keyword
	matching on location text if type is missing.
	Args:
		evidenceItem: the evidence object with type and location fields
	*/
	// Evidence items already have a type property from generation
	if (evidenceItem.type) {
		return evidenceItem.type;
	}

	// Fallback: try to guess from location text
	var desc = (evidenceItem.location || '').toLowerCase();
	if (desc.indexOf('blood') !== -1 || desc.indexOf('red stain') !== -1) {
		return 'blood';
	}
	if (desc.indexOf('hair') !== -1 || desc.indexOf('strand') !== -1) {
		return 'hair';
	}
	if (desc.indexOf('saliva') !== -1 || desc.indexOf('wet spot') !== -1) {
		return 'saliva';
	}
	if (desc.indexOf('fiber') !== -1 || desc.indexOf('thread') !== -1) {
		return 'fiber';
	}
	return 'touch_dna';
}

/* ============================================ */
function submitCollectionForm(evidenceIndex) {
	/*
	Reads the collection form fields from the modal and calls
	confirmCollection with the player's input.
	Args:
		evidenceIndex: index in gameState.availableEvidence
	*/
	var labelInput = document.getElementById('sample-label');
	var typeSelect = document.getElementById('evidence-type-select');
	var notesInput = document.getElementById('location-notes');

	// Read form values with fallback defaults
	var label = labelInput ? labelInput.value.trim() : '';
	var evidenceType = typeSelect ? typeSelect.value : 'touch_dna';
	var locationNotes = notesInput ? notesInput.value.trim() : '';

	// Validate that the label is not empty
	if (label.length === 0) {
		label = 'Sample #' + (gameState.collectedSamples.length + 1);
	}

	closeModal();
	confirmCollection(evidenceIndex, label, evidenceType, locationNotes);
}

/* ============================================ */
function confirmCollection(evidenceIndex, label, evidenceType, locationNotes) {
	/*
	Finalizes evidence collection. Creates a sample object, updates
	game state, scores chain of custody, and refreshes the UI.
	Args:
		evidenceIndex: index in gameState.availableEvidence
		label: player-assigned label string
		evidenceType: player-selected evidence type string
		locationNotes: player-entered location notes string
	*/
	var evidenceItem = gameState.availableEvidence[evidenceIndex];

	// Mark the evidence as collected in the available list
	evidenceItem.collected = true;

	// Decrement swab count
	gameState.swabsRemaining--;

	// Determine chain of custody quality based on labeling
	var custodyScore = evaluateChainOfCustody(evidenceItem, label, evidenceType, locationNotes);

	// Build the sample object
	var sample = {
		id: 'sample-' + Date.now() + '-' + evidenceIndex,
		label: label,
		evidenceType: evidenceType,
		actualType: evidenceItem.type,
		locationNotes: locationNotes,
		location: evidenceItem.location,
		quality: evidenceItem.quality,
		contaminated: evidenceItem.contaminated || false,
		chainOfCustody: custodyScore,
		sourceIndex: evidenceIndex,
		collectedAt: gameState.round,
		// Copy source character ID for lab test lookups
		sourceCharacter: evidenceItem.sourceCharacter || null,
		mixedWith: evidenceItem.mixedWith || null
	};

	// Add the sample to the player's collection
	gameState.collectedSamples.push(sample);

	// Log this collection event
	gameState.evidenceLog.push({
		action: 'collected',
		round: gameState.round,
		label: label,
		type: evidenceType,
		actualType: evidenceItem.type,
		location: evidenceItem.location,
		contaminated: sample.contaminated,
		chainOfCustody: custodyScore
	});

	// Award sample handling points
	var handlingPoints = calculateHandlingPoints(sample);
	gameState.currentRoundScore.sampleHandling += handlingPoints;

	// Award chain of custody points
	gameState.currentRoundScore.chainOfCustody += custodyScore;

	// Re-render the scene to show updated state
	renderScenePhase();
}

/* ============================================ */
function evaluateChainOfCustody(evidenceItem, label, evidenceType, locationNotes) {
	/*
	Scores the player's evidence labeling for chain of custody accuracy.
	Better labels earn more points.
	Returns an integer score from 0 to 3.
	Args:
		evidenceItem: the original evidence object
		label: player-assigned label
		evidenceType: player-selected type
		locationNotes: player-entered notes
	*/
	var score = 0;

	// +1 point if the label is descriptive (more than 5 characters)
	if (label.length > 5) {
		score += 1;
	}

	// +1 point if the evidence type matches the actual type
	if (evidenceType === evidenceItem.type) {
		score += 1;
	}

	// +1 point if location notes are provided and non-trivial
	if (locationNotes.length > 3) {
		score += 1;
	}

	return score;
}

/* ============================================ */
function calculateHandlingPoints(sample) {
	/*
	Calculates points awarded for proper sample handling.
	Contaminated samples earn fewer points.
	Returns an integer point value.
	Args:
		sample: the collected sample object
	*/
	var points = 2;

	// Penalty for contamination
	if (sample.contaminated) {
		points = 0;
	}

	// Bonus for high-quality evidence
	if (sample.quality === 'pristine') {
		points += 1;
	}

	return points;
}

/* ============================================ */
function updateEvidenceSidebar() {
	/*
	Updates the #evidence-list sidebar panel with all collected samples.
	Shows label, type, quality, contamination warnings, and custody status.
	*/
	var listEl = document.getElementById('evidence-list');
	if (!listEl) {
		return;
	}

	var samples = gameState.collectedSamples;

	// Show empty state if no samples collected yet
	if (samples.length === 0) {
		listEl.innerHTML = '<p class="empty-state">No evidence collected yet.</p>';
		return;
	}

	var html = '';
	for (var i = 0; i < samples.length; i++) {
		var sample = samples[i];
		html += buildSidebarSampleEntry(sample, i);
	}

	listEl.innerHTML = html;
}

/* ============================================ */
function buildSidebarSampleEntry(sample, index) {
	/*
	Builds HTML for a single sample entry in the evidence sidebar.
	Args:
		sample: the collected sample object
		index: position in collectedSamples array
	Returns HTML string.
	*/
	var html = '';
	var entryClass = 'sidebar-sample';
	if (sample.contaminated) {
		entryClass += ' sample-contaminated';
	}

	html += '<div class="' + entryClass + '">';

	// Sample label
	html += '<div class="sample-label">';
	html += escapeHtml(sample.label);
	html += '</div>';

	// Type tag
	var typeLabel = sample.evidenceType.replace('_', ' ');
	html += '<span class="sample-type-tag tag-' + sample.evidenceType + '">';
	html += typeLabel;
	html += '</span>';

	// Quality indicator
	html += '<span class="sample-quality quality-' + sample.quality + '">';
	html += sample.quality;
	html += '</span>';

	// Contamination warning
	if (sample.contaminated) {
		html += '<div class="contamination-warning">';
		html += '!! CONTAMINATED';
		html += '</div>';
	}

	// Chain of custody status
	var custodyText = 'Unlabeled';
	if (sample.chainOfCustody >= 3) {
		custodyText = 'Fully labeled';
	} else if (sample.chainOfCustody >= 1) {
		custodyText = 'Partially labeled';
	}
	html += '<div class="custody-status custody-' + sample.chainOfCustody + '">';
	html += 'Custody: ' + custodyText;
	html += '</div>';

	html += '</div>';
	return html;
}

/* ============================================ */
function getEvidenceDescription(evidenceType) {
	/*
	Returns a random description string for the given evidence type.
	Falls back to a generic description if the type is unrecognized.
	Args:
		evidenceType: string key from EVIDENCE_TYPES
	*/
	var descriptions = EVIDENCE_DESCRIPTIONS[evidenceType];
	if (!descriptions || descriptions.length === 0) {
		return 'Trace biological evidence found at the scene.';
	}
	var randomIndex = Math.floor(Math.random() * descriptions.length);
	return descriptions[randomIndex];
}

/* ============================================ */
function escapeHtml(text) {
	/*
	Escapes HTML special characters to prevent injection.
	Returns the sanitized string.
	Args:
		text: raw string to escape
	*/
	if (typeof text !== 'string') {
		return '';
	}
	var escaped = text;
	escaped = escaped.replace(/&/g, '&amp;');
	escaped = escaped.replace(/</g, '&lt;');
	escaped = escaped.replace(/>/g, '&gt;');
	escaped = escaped.replace(/"/g, '&quot;');
	escaped = escaped.replace(/'/g, '&#39;');
	return escaped;
}

/* ============================================ */
/* lab_phase.js */
/* ============================================ */

/* ============================================ */
/* LAB PHASE - Laboratory Analysis Phase        */
/* ============================================ */

/* ============================================ */
function renderLabPhase() {
	/* Render the laboratory analysis phase UI into #main-panel.
	   Uses a button-based interface: pick a sample, then pick a test.
	   Also updates the evidence sidebar with lab results. */
	var panel = document.getElementById('main-panel');
	if (!panel) {
		return;
	}

	var html = '';
	html += '<div id="lab-phase-container">';

	// Header with tests remaining counter
	html += '<div class="lab-header">';
	html += '<h2>Laboratory Analysis</h2>';
	html += '<p class="resource-counter">Tests remaining: <strong id="tests-remaining-count">';
	html += gameState.testsRemaining + '</strong></p>';
	html += '</div>';

	// Step 1: Sample selection buttons
	html += '<div class="lab-section">';
	html += '<h3>1. Select a Sample</h3>';
	html += '<div class="lab-button-grid" id="sample-buttons">';
	for (var i = 0; i < gameState.collectedSamples.length; i++) {
		var sample = gameState.collectedSamples[i];
		var sampleLabel = buildSampleLabel(sample, i);
		var selectedClass = (gameState._selectedSampleIndex === i) ? ' selected' : '';
		html += '<button class="lab-sample-btn' + selectedClass + '" ';
		html += 'onclick="selectSample(' + i + ')">';
		html += '<span class="sample-btn-type">' + (sample.actualType || 'evidence').toUpperCase() + '</span>';
		html += '<span class="sample-btn-label">' + escapeHtml(sample.label || sample.location || '') + '</span>';
		html += '<span class="sample-btn-quality">' + (sample.quality || '') + '</span>';
		html += '</button>';
	}
	html += '</div>';
	html += '</div>';

	// Step 2: Test type buttons (shown after sample selection)
	html += '<div class="lab-section" id="test-type-section">';
	html += '<h3>2. Choose a Test</h3>';
	if (gameState._selectedSampleIndex !== undefined && gameState._selectedSampleIndex !== null) {
		html += buildTestButtons(gameState._selectedSampleIndex);
	} else {
		html += '<p class="empty-state">Select a sample first.</p>';
	}
	html += '</div>';

	// Control toggle
	html += '<div class="lab-section lab-control-toggle">';
	html += '<label class="control-label">';
	html += '<input type="checkbox" id="control-checkbox" checked> ';
	html += 'Include Control Sample <span class="hint-text">(+points for quality)</span>';
	html += '</label>';
	html += '</div>';

	// Active result display area
	html += '<div id="lab-result-display">';
	if (gameState.testResults.length === 0) {
		html += '<p class="empty-state">Pick a sample and test to see results here.</p>';
	}
	html += '</div>';

	// Previously run test results (scrollable)
	html += '<div id="previous-results">';
	if (gameState.testResults.length > 0) {
		html += '<h3>Previous Results</h3>';
		html += '<div id="previous-results-list">';
		for (var j = gameState.testResults.length - 1; j >= 0; j--) {
			html += buildPreviousResultCard(gameState.testResults[j], j);
		}
		html += '</div>';
	}
	html += '</div>';

	html += '</div>';
	panel.innerHTML = html;

	// Update sidebar
	updateLabResultsSidebar();
}

/* ============================================ */
function selectSample(index) {
	/* Handle clicking a sample button. Highlights selection and
	   reveals compatible test type buttons.

	Args:
		index: index into gameState.collectedSamples
	*/
	gameState._selectedSampleIndex = index;

	// Update button highlights
	var btns = document.querySelectorAll('.lab-sample-btn');
	for (var i = 0; i < btns.length; i++) {
		btns[i].classList.remove('selected');
	}
	if (btns[index]) {
		btns[index].classList.add('selected');
	}

	// Populate test buttons
	var section = document.getElementById('test-type-section');
	if (section) {
		section.innerHTML = '<h3>2. Choose a Test</h3>' + buildTestButtons(index);
	}
}

/* ============================================ */
function buildTestButtons(sampleIndex) {
	/* Build HTML for test type buttons compatible with the selected sample.

	Args:
		sampleIndex: index into gameState.collectedSamples

	Returns:
		string: HTML for test buttons
	*/
	var sample = gameState.collectedSamples[sampleIndex];
	if (!sample) {
		return '<p class="empty-state">Invalid sample.</p>';
	}

	var sampleType = sample.actualType || '';
	var html = '<div class="lab-button-grid" id="test-buttons">';
	var testKeys = Object.keys(FORENSIC_TESTS);
	var anyCompatible = false;

	for (var i = 0; i < testKeys.length; i++) {
		var testKey = testKeys[i];
		var testDef = FORENSIC_TESTS[testKey];

		// Check compatibility
		var compatible = false;
		for (var j = 0; j < testDef.sampleTypes.length; j++) {
			if (testDef.sampleTypes[j] === sampleType) {
				compatible = true;
				break;
			}
		}

		if (compatible) {
			anyCompatible = true;
			var disabled = (gameState.testsRemaining <= 0) ? ' disabled' : '';
			html += '<button class="lab-test-btn"' + disabled;
			html += ' onclick="runTestDirect(' + sampleIndex + ', \'' + testKey + '\')">';
			html += '<span class="test-btn-name">' + testDef.name + '</span>';
			html += '<span class="test-btn-desc">' + (testDef.description || '') + '</span>';
			html += '</button>';
		}
	}

	if (!anyCompatible) {
		html += '<p class="empty-state">No compatible tests for this sample type.</p>';
	}

	html += '</div>';
	return html;
}

/* ============================================ */
function runTestDirect(sampleIndex, testType) {
	/* Run a test directly from button click (no dropdowns needed).

	Args:
		sampleIndex: index into gameState.collectedSamples
		testType: string key from FORENSIC_TESTS
	*/
	if (gameState.testsRemaining <= 0) {
		showModal('No Tests Remaining',
			'<p>You have used all available tests for this round.</p>' +
			'<p>Proceed to the Case Board to evaluate your evidence.</p>');
		return;
	}

	var sample = gameState.collectedSamples[sampleIndex];
	if (!sample) {
		return;
	}

	var controlCheckbox = document.getElementById('control-checkbox');
	var includeControl = controlCheckbox ? controlCheckbox.checked : false;

	// Decrement tests remaining
	gameState.testsRemaining--;
	var countDisplay = document.getElementById('tests-remaining-count');
	if (countDisplay) {
		countDisplay.textContent = gameState.testsRemaining;
	}

	// Generate the test result
	var result = generateTestResult(sample, testType, includeControl);
	result.sampleIndex = sampleIndex;
	result.sampleType = sample.actualType || '';
	result.interpretation = '';
	gameState.testResults.push(result);
	gameState.currentTestResult = result;

	// Score: test selection
	scoreTestSelection(sample, testType);

	// Score: control usage
	if (includeControl) {
		gameState.currentRoundScore.controlUsage += SCORE_WEIGHTS.controlUsage;
	}

	// Display the result
	displayTestResult(result);

	// Show the interpretation form
	var resultIndex = gameState.testResults.length - 1;
	showInterpretationForm(resultIndex);

	// Update previous results list and sidebar
	updatePreviousResultsList();
	updateLabResultsSidebar();

	// Disable test buttons if no tests remain
	if (gameState.testsRemaining <= 0) {
		var testBtns = document.querySelectorAll('.lab-test-btn');
		for (var i = 0; i < testBtns.length; i++) {
			testBtns[i].disabled = true;
		}
	}
}

/* ============================================ */
function buildSampleLabel(sample, index) {
	/* Build a human-readable label for a collected evidence sample.

	Args:
		sample: sample object from gameState.collectedSamples
		index: numeric index of the sample

	Returns:
		string: descriptive label for dropdown display
	*/
	// Use player-assigned label if available
	if (sample.label && sample.label.length > 0) {
		return '#' + (index + 1) + ': ' + sample.label;
	}
	// Fallback to type and location
	var typeLabel = sample.actualType || 'evidence';
	typeLabel = typeLabel.replace(/_/g, ' ');
	var location = sample.location || '';
	var label = '#' + (index + 1) + ': ' + typeLabel;
	if (location) {
		label += ' (' + location + ')';
	}
	return label;
}

/* ============================================ */
function buildPreviousResultCard(result, index) {
	/* Build an HTML card summarizing a previously run test result.

	Args:
		result: test result object from gameState.testResults
		index: index in the testResults array

	Returns:
		string: HTML string for the result card
	*/
	var card = '';
	card += '<div class="result-card" id="result-card-' + index + '">';
	card += '<div class="result-card-header">';

	// Test type name
	var testInfo = FORENSIC_TESTS[result.testType];
	var testName = testInfo ? testInfo.name : result.testType;
	card += '<strong>' + testName + '</strong>';

	// Sample info
	var sampleDesc = result.sampleType || 'unknown';
	sampleDesc = sampleDesc.replace(/_/g, ' ');
	card += ' <span class="result-meta">(' + sampleDesc + ')</span>';
	card += '</div>';

	// Brief summary of the result
	card += '<div class="result-card-body">';
	card += '<p>' + getResultSummaryText(result) + '</p>';

	// Show stored interpretation if any
	if (result.interpretation) {
		card += '<p class="result-interpretation"><em>Interpretation: ';
		card += escapeHtml(result.interpretation) + '</em></p>';
	}

	card += '</div>';
	card += '</div>';
	return card;
}

/* ============================================ */
function getResultSummaryText(result) {
	/* Generate a short summary text for a test result.

	Args:
		result: test result object

	Returns:
		string: brief human-readable summary
	*/
	if (!result) {
		return 'No data available.';
	}

	var summary = '';
	switch (result.testType) {
		case 'blood_type':
			summary = 'Blood type: ' + (result.bloodType || '?');
			if (result.rhFactor !== undefined) {
				summary += (result.rhFactor ? '+' : '-');
			}
			break;
		case 'rflp':
			var fragCount = result.fragments ? result.fragments.length : 0;
			summary = 'RFLP analysis: ' + fragCount + ' fragments detected';
			if (result.enzyme) {
				summary += ' (enzyme: ' + result.enzyme + ')';
			}
			break;
		case 'str':
			var lociCount = result.strProfile ? Object.keys(result.strProfile).length : 0;
			summary = 'STR profile: ' + lociCount + ' loci analyzed';
			break;
		case 'mtdna':
			summary = 'mtDNA haplotype: ' + (result.haplotype || '?');
			break;
		case 'restriction':
			var rFragCount = result.fragments ? result.fragments.length : 0;
			summary = 'Restriction digest: ' + rFragCount + ' fragments';
			if (result.enzyme) {
				summary += ' (' + result.enzyme + ')';
			}
			break;
		default:
			summary = 'Test completed.';
	}
	return summary;
}

/* escapeHtml is defined in scene_phase.js (loaded before this file) */

/* ============================================ */
function scoreTestSelection(sample, testType) {
	/* Award points for selecting an appropriate test for the
	   given sample type. More informative tests earn more points.

	Args:
		sample: the evidence sample object
		testType: string key from FORENSIC_TESTS
	*/
	var sampleType = sample.actualType || '';
	var testDef = FORENSIC_TESTS[testType];
	if (!testDef) {
		return;
	}

	// Check if the test is compatible with the sample type
	var isCompatible = false;
	for (var i = 0; i < testDef.sampleTypes.length; i++) {
		if (testDef.sampleTypes[i] === sampleType) {
			isCompatible = true;
			break;
		}
	}

	if (isCompatible) {
		// Award points based on test informativeness
		var points = 0;
		switch (testType) {
			case 'str':
				// Most discriminating test
				points = SCORE_WEIGHTS.testSelection;
				break;
			case 'rflp':
				// Highly discriminating
				points = Math.floor(SCORE_WEIGHTS.testSelection * 0.8);
				break;
			case 'restriction':
				// Moderately useful
				points = Math.floor(SCORE_WEIGHTS.testSelection * 0.6);
				break;
			case 'blood_type':
				// Limited discrimination (many people share types)
				points = Math.floor(SCORE_WEIGHTS.testSelection * 0.4);
				break;
			case 'mtdna':
				// Useful for degraded/hair only
				if (sampleType === 'hair') {
					points = SCORE_WEIGHTS.testSelection;
				} else {
					points = Math.floor(SCORE_WEIGHTS.testSelection * 0.5);
				}
				break;
			default:
				points = Math.floor(SCORE_WEIGHTS.testSelection * 0.3);
		}
		gameState.currentRoundScore.testSelection += points;
	}
}

/* ============================================ */
function displayTestResult(result) {
	/* Render a test result in the lab result display area using
	   the appropriate visualization method for the test type.

	Args:
		result: test result object from generateTestResult()
	*/
	if (!result) {
		return;
	}

	switch (result.testType) {
		case 'blood_type':
			displayBloodTypeResult(result);
			break;
		case 'rflp':
			displayRFLPResult(result);
			break;
		case 'str':
			displaySTRResult(result);
			break;
		case 'mtdna':
			displayMtDNAResult(result);
			break;
		case 'restriction':
			displayRestrictionResult(result);
			break;
		default:
			displayGenericResult(result);
	}
}

/* ============================================ */
function displayBloodTypeResult(result) {
	/* Render a blood typing result as four agglutination wells
	   using HTML and CSS. Each well shows either clumped dots
	   (positive/agglutinated) or evenly distributed dots (negative).

	Args:
		result: blood typing test result object with fields:
			bloodType, rhFactor, agglutination
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var bloodType = result.bloodType || '?';
	var rhFactor = result.rhFactor;

	// Determine which antibodies react
	var antiAPositive = (bloodType === 'A' || bloodType === 'AB');
	var antiBPositive = (bloodType === 'B' || bloodType === 'AB');
	var antiDPositive = (rhFactor === true);

	var html = '';
	html += '<div class="blood-type-result">';
	html += '<h3>Blood Typing Result (ABO/Rh)</h3>';

	// Four wells row
	html += '<div class="blood-wells-row">';

	// Anti-A well
	html += buildBloodWellHtml('Anti-A', antiAPositive);
	// Anti-B well
	html += buildBloodWellHtml('Anti-B', antiBPositive);
	// Anti-D (Rh) well
	html += buildBloodWellHtml('Anti-D (Rh)', antiDPositive);
	// Control well (should always be negative)
	html += buildBloodWellHtml('Control', false);

	html += '</div>';

	// Interpretation guide
	html += '<div class="blood-type-guide">';
	html += '<p><strong>Result:</strong> Type <strong>' + bloodType;
	html += (rhFactor ? '+' : '-') + '</strong></p>';
	html += '<p class="hint-text">Agglutination (clumping) indicates a positive reaction.</p>';
	html += '</div>';

	html += '</div>';
	display.innerHTML = html;
}

/* ============================================ */
function buildBloodWellHtml(label, isPositive) {
	/* Build HTML for a single blood typing well showing either
	   agglutinated (clumped) or smooth (non-reactive) pattern.

	Args:
		label: antibody name for the well label
		isPositive: boolean, true if agglutination occurred

	Returns:
		string: HTML for the well element
	*/
	var wellClass = isPositive ? 'blood-well agglutinated' : 'blood-well smooth';
	var html = '';
	html += '<div class="' + wellClass + '">';
	html += '<div class="well-label">' + label + '</div>';
	html += '<div class="well-circle">';

	if (isPositive) {
		// Draw clumped dots for positive reaction
		html += '<div class="clump-pattern">';
		for (var i = 0; i < 12; i++) {
			// Position clumped dots in irregular clusters
			var top = 20 + Math.floor(i / 4) * 22 + (i % 2) * 5;
			var left = 15 + (i % 4) * 18 + (i % 3) * 3;
			html += '<span class="dot clumped" style="top:' + top + 'px;left:' + left + 'px;"></span>';
		}
		html += '</div>';
	} else {
		// Draw evenly distributed dots for negative reaction
		html += '<div class="smooth-pattern">';
		for (var j = 0; j < 16; j++) {
			var sTop = 10 + Math.floor(j / 4) * 20;
			var sLeft = 10 + (j % 4) * 20;
			html += '<span class="dot smooth" style="top:' + sTop + 'px;left:' + sLeft + 'px;"></span>';
		}
		html += '</div>';
	}

	html += '</div>';
	html += '<div class="well-result">' + (isPositive ? '+' : '-') + '</div>';
	html += '</div>';
	return html;
}

/* ============================================ */
function displayRFLPResult(result) {
	/* Render an RFLP analysis result as a gel electrophoresis image.
	   Shows the evidence sample alongside suspect reference profiles.

	Args:
		result: RFLP test result object with fields:
			fragments, enzyme, suspectProfiles, controlFragments
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var html = '';
	html += '<div class="rflp-result">';
	html += '<h3>RFLP Gel Electrophoresis</h3>';

	// Canvas container for inline gel display
	html += '<div class="gel-container">';
	html += '<canvas id="rflp-inline-canvas" width="700" height="450"></canvas>';
	html += '</div>';

	// Enlarge button
	html += '<button class="btn btn-small" onclick="showRFLPGelModal()">Enlarge Gel</button>';

	// Enzyme info
	html += '<p class="result-meta">Enzyme used: <strong>';
	html += (result.enzyme || 'EcoRI') + '</strong></p>';

	html += '</div>';
	display.innerHTML = html;

	// Build lanes for gel rendering
	var lanes = buildRFLPLanes(result);
	var gelTitle = 'RFLP Analysis - ' + (result.enzyme || 'EcoRI');

	// Store lanes for modal enlargement
	gameState._lastRFLPLanes = lanes;
	gameState._lastRFLPTitle = gelTitle;

	// Defer rendering until after the DOM has updated the new canvas
	requestAnimationFrame(function() {
		renderGel('rflp-inline-canvas', lanes, gelTitle);
	});
}

/* ============================================ */
function buildRFLPLanes(result) {
	/* Build lane data for RFLP gel rendering from a test result.

	Args:
		result: RFLP test result object

	Returns:
		array: lane objects for renderGel()
	*/
	var lanes = [];

	// Evidence sample lane
	lanes.push({
		label: 'Evidence',
		fragments: result.fragments || [],
		intensity: 0.9
	});

	// Control lane if included
	if (result.controlFragments) {
		lanes.push({
			label: 'Control',
			fragments: result.controlFragments,
			intensity: 0.7
		});
	}

	// Suspect reference lanes
	if (result.suspectProfiles) {
		var suspectIds = Object.keys(result.suspectProfiles);
		for (var i = 0; i < suspectIds.length; i++) {
			var suspectId = suspectIds[i];
			var suspect = getSuspectById(suspectId);
			var suspectName = suspect ? suspect.name.split(' ')[0] : suspectId;
			lanes.push({
				label: suspectName,
				fragments: result.suspectProfiles[suspectId],
				intensity: 0.85
			});
		}
	}

	return lanes;
}

/* ============================================ */
function showRFLPGelModal() {
	/* Show the last rendered RFLP gel in an enlarged modal view. */
	if (gameState._lastRFLPLanes && gameState._lastRFLPTitle) {
		showGelInModal(gameState._lastRFLPLanes, gameState._lastRFLPTitle);
	}
}

/* ============================================ */
function displaySTRResult(result) {
	/* Render an STR profiling result as a bar chart of allele peaks
	   using the gel canvas repurposed as a chart area.

	Args:
		result: STR test result object with fields:
			strProfile (object mapping locus to allele arrays)
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var html = '';
	html += '<div class="str-result">';
	html += '<h3>PCR/STR Profiling Result</h3>';

	// Inline canvas for STR chart
	html += '<div class="gel-container">';
	html += '<canvas id="str-inline-canvas" width="700" height="450"></canvas>';
	html += '</div>';

	// Profile summary table
	html += '<div class="str-profile-table">';
	html += '<table>';
	html += '<tr><th>Locus</th><th>Allele 1</th><th>Allele 2</th></tr>';

	var strProfile = result.strProfile || {};
	var loci = Object.keys(strProfile);
	for (var i = 0; i < loci.length; i++) {
		var locus = loci[i];
		var alleles = strProfile[locus];
		var a1 = (alleles && alleles.length > 0) ? alleles[0] : '-';
		var a2 = (alleles && alleles.length > 1) ? alleles[1] : '-';
		html += '<tr>';
		html += '<td>' + locus + '</td>';
		html += '<td>' + a1 + '</td>';
		html += '<td>' + a2 + '</td>';
		html += '</tr>';
	}

	html += '</table>';
	html += '</div>';

	html += '</div>';
	display.innerHTML = html;

	// Defer canvas rendering until after DOM update
	var chartTitle = 'STR Electropherogram';
	requestAnimationFrame(function() {
		renderSTRChart('str-inline-canvas', strProfile, chartTitle);
	});
}

/* ============================================ */
function displayMtDNAResult(result) {
	/* Render a mitochondrial DNA analysis result as a text/HTML
	   display showing the haplotype identifier and relevant notes.

	Args:
		result: mtDNA test result object with fields:
			haplotype, haplogroup
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var haplotype = result.haplotype || 'Unknown';

	var html = '';
	html += '<div class="mtdna-result">';
	html += '<h3>Mitochondrial DNA Analysis</h3>';

	// Haplotype display card
	html += '<div class="mtdna-card">';
	html += '<div class="mtdna-haplotype">';
	html += '<span class="mtdna-label">Haplotype:</span> ';
	html += '<span class="mtdna-value">' + haplotype + '</span>';
	html += '</div>';

	// Haplogroup info if available
	if (result.haplogroup) {
		html += '<div class="mtdna-haplogroup">';
		html += '<span class="mtdna-label">Haplogroup:</span> ';
		html += '<span class="mtdna-value">' + result.haplogroup + '</span>';
		html += '</div>';
	}

	html += '</div>';

	// Educational note about maternal inheritance
	html += '<div class="mtdna-note">';
	html += '<p><strong>Note:</strong> Mitochondrial DNA is inherited ';
	html += 'exclusively from the mother. All individuals sharing the same ';
	html += 'maternal lineage will have identical mtDNA haplotypes. This ';
	html += 'means mtDNA cannot distinguish between maternally related ';
	html += 'individuals, but it can <em>exclude</em> individuals who do ';
	html += 'not share the same maternal line.</p>';
	html += '<p class="hint-text">mtDNA is especially useful for degraded ';
	html += 'samples and hair without roots, where nuclear DNA may be ';
	html += 'unavailable.</p>';
	html += '</div>';

	html += '</div>';
	display.innerHTML = html;
}

/* ============================================ */
function displayRestrictionResult(result) {
	/* Render a restriction enzyme digest result as a simplified gel.

	Args:
		result: restriction digest test result with fields:
			fragments, enzyme, suspectProfiles
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var enzyme = result.enzyme || 'EcoRI';

	var html = '';
	html += '<div class="restriction-result">';
	html += '<h3>Restriction Enzyme Digest</h3>';

	// Inline canvas
	html += '<div class="gel-container">';
	html += '<canvas id="restriction-inline-canvas" width="700" height="450"></canvas>';
	html += '</div>';

	// Enzyme info
	html += '<p class="result-meta">Enzyme: <strong>' + enzyme + '</strong></p>';
	html += '<p class="hint-text">Compare band patterns between the evidence ';
	html += 'and suspect lanes. Matching patterns indicate the same DNA source.</p>';

	html += '</div>';
	display.innerHTML = html;

	// Build suspect fragments map for the restriction gel
	var suspectFragments = {};
	if (result.suspectProfiles) {
		var suspectIds = Object.keys(result.suspectProfiles);
		for (var i = 0; i < suspectIds.length; i++) {
			var sid = suspectIds[i];
			var suspect = getSuspectById(sid);
			var name = suspect ? suspect.name : sid;
			suspectFragments[name] = result.suspectProfiles[sid];
		}
	}

	var sampleFragments = result.fragments || [];
	// Defer canvas rendering until after DOM update
	requestAnimationFrame(function() {
		renderRestrictionGel('restriction-inline-canvas', sampleFragments, suspectFragments, enzyme);
	});
}

/* ============================================ */
function displayGenericResult(result) {
	/* Fallback display for unrecognized test types.

	Args:
		result: test result object
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var html = '';
	html += '<div class="generic-result">';
	html += '<h3>Test Result</h3>';
	html += '<p>' + getResultSummaryText(result) + '</p>';
	html += '</div>';
	display.innerHTML = html;
}

/* ============================================ */
function showInterpretationForm(resultIndex) {
	/* Display button-based interpretation choices below the test result.
	   Player picks a conclusion quality level for this evidence.

	Args:
		resultIndex: index of the test result in gameState.testResults
	*/
	var display = document.getElementById('lab-result-display');
	if (!display) {
		return;
	}

	var html = '';
	html += '<div class="interpretation-form" id="interpretation-form">';
	html += '<h4>How do you interpret this result?</h4>';
	html += '<div class="interpretation-buttons">';

	// Button choices for interpretation quality
	var choices = [
		{ label: 'Definitive Match', value: 'definitive_match', desc: 'This evidence clearly identifies a specific suspect' },
		{ label: 'Consistent With', value: 'consistent', desc: 'Evidence is consistent with one or more suspects' },
		{ label: 'Partial Match', value: 'partial_match', desc: 'Some elements match but not all' },
		{ label: 'Inconclusive', value: 'inconclusive', desc: 'Cannot draw a clear conclusion from this test' },
		{ label: 'Excludes Suspect(s)', value: 'excludes', desc: 'This evidence rules out one or more suspects' }
	];

	for (var i = 0; i < choices.length; i++) {
		var c = choices[i];
		html += '<button class="btn interpretation-btn" ';
		html += 'onclick="submitInterpretation(' + resultIndex + ', \'' + c.value + '\')">';
		html += '<strong>' + c.label + '</strong>';
		html += '<span class="interpretation-btn-desc">' + c.desc + '</span>';
		html += '</button>';
	}

	html += '</div>';
	html += '</div>';

	// Append the form to the display area
	display.innerHTML += html;
}

/* ============================================ */
function submitInterpretation(resultIndex, choiceValue) {
	/* Save the player's interpretation choice for a test result and
	   award scoring points based on the appropriateness of the choice.

	Args:
		resultIndex: index in gameState.testResults
		choiceValue: string key of the interpretation choice
	*/
	if (!choiceValue) {
		return;
	}

	// Map choice to display text
	var choiceLabels = {
		definitive_match: 'Definitive Match',
		consistent: 'Consistent With Suspect(s)',
		partial_match: 'Partial Match',
		inconclusive: 'Inconclusive',
		excludes: 'Excludes Suspect(s)'
	};
	var interpretationText = choiceLabels[choiceValue] || choiceValue;

	// Store the interpretation with the test result
	if (resultIndex >= 0 && resultIndex < gameState.testResults.length) {
		gameState.testResults[resultIndex].interpretation = interpretationText;
		gameState.testResults[resultIndex].interpretationChoice = choiceValue;
	}

	// Score the interpretation based on choice appropriateness
	var points = scoreInterpretationChoice(choiceValue, resultIndex);
	gameState.currentRoundScore.interpretation += points;

	// Remove the form and show confirmation
	var form = document.getElementById('interpretation-form');
	if (form) {
		var confirmHtml = '';
		confirmHtml += '<div class="interpretation-saved">';
		confirmHtml += '<p><strong>Logged: ' + interpretationText + '</strong>';
		if (points > 0) {
			confirmHtml += ' (+' + points + ' pts)</p>';
		} else if (points < 0) {
			confirmHtml += ' (' + points + ' pts - overclaiming penalty)</p>';
		} else {
			confirmHtml += '</p>';
		}
		confirmHtml += '</div>';
		form.innerHTML = confirmHtml;
	}

	// Update sidebar and previous results
	updateLabResultsSidebar();
	updatePreviousResultsList();
}

/* ============================================ */
function scoreInterpretation(text) {
	/* Evaluate interpretation text and return a score based on
	   the presence of good forensic language vs overclaiming.

	Args:
		text: the player's interpretation string

	Returns:
		number: positive or negative score adjustment
	*/
	var lowerText = text.toLowerCase();
	var score = 0;

	// Good forensic keywords (earn points)
	var goodKeywords = ['match', 'exclude', 'consistent', 'inconclusive', 'partial', 'degraded'];
	for (var i = 0; i < goodKeywords.length; i++) {
		if (lowerText.indexOf(goodKeywords[i]) !== -1) {
			score += 3;
		}
	}

	// Overclaiming keywords (lose points)
	var badKeywords = ['definitely', 'proves', '100%', 'certain', 'no doubt', 'absolute'];
	for (var j = 0; j < badKeywords.length; j++) {
		if (lowerText.indexOf(badKeywords[j]) !== -1) {
			score -= 4;
			// Also apply the overclaiming penalty to the round score
			gameState.currentRoundScore.overclaimingPenalty += SCORE_WEIGHTS.overclaimingPenalty;
		}
	}

	// Cap the positive score at the interpretation weight
	score = Math.min(score, SCORE_WEIGHTS.interpretation);
	return score;
}

/* ============================================ */
function scoreInterpretationChoice(choiceValue, resultIndex) {
	/* Score a button-based interpretation choice.
	   Rewards cautious, appropriate conclusions. Penalizes overclaiming.

	Args:
		choiceValue: string key of the interpretation choice
		resultIndex: index into gameState.testResults

	Returns:
		number: score adjustment
	*/
	var result = gameState.testResults[resultIndex];
	if (!result) {
		return 0;
	}

	// Award points based on choice appropriateness
	switch (choiceValue) {
		case 'definitive_match':
			// Bold claim - penalize unless blood type is very distinctive
			if (result.testType === 'blood_type') {
				// Blood typing alone can never be definitive
				gameState.currentRoundScore.overclaimingPenalty += SCORE_WEIGHTS.overclaimingPenalty;
				return -3;
			}
			// RFLP can be strong but still not absolute
			return 2;
		case 'consistent':
			// Good, cautious scientific language - always reasonable
			return SCORE_WEIGHTS.interpretation;
		case 'partial_match':
			// Appropriate for degraded samples or limited data
			return Math.floor(SCORE_WEIGHTS.interpretation * 0.8);
		case 'inconclusive':
			// Safe choice but less informative
			return Math.floor(SCORE_WEIGHTS.interpretation * 0.5);
		case 'excludes':
			// Strong claim but valid if evidence supports it
			return Math.floor(SCORE_WEIGHTS.interpretation * 0.9);
		default:
			return 0;
	}
}

/* ============================================ */
function updatePreviousResultsList() {
	/* Refresh the previous results scrollable list in the lab UI
	   with the latest test results from the game state. */
	var listContainer = document.getElementById('previous-results-list');
	if (!listContainer) {
		return;
	}

	if (gameState.testResults.length === 0) {
		listContainer.innerHTML = '<p class="empty-state">No tests run yet this round.</p>';
		return;
	}

	var html = '';
	// Render in reverse order so newest results appear first
	for (var i = gameState.testResults.length - 1; i >= 0; i--) {
		html += buildPreviousResultCard(gameState.testResults[i], i);
	}
	listContainer.innerHTML = html;
}

/* ============================================ */
function updateLabResultsSidebar() {
	/* Update the #results-list element in the evidence sidebar
	   with a summary of all test results run this round. */
	var resultsList = document.getElementById('results-list');
	var summaryContainer = document.getElementById('lab-results-summary');
	if (!resultsList) {
		return;
	}

	if (gameState.testResults.length === 0) {
		// Hide the lab results section if no tests have been run
		if (summaryContainer) {
			summaryContainer.style.display = 'none';
		}
		return;
	}

	// Show the lab results section
	if (summaryContainer) {
		summaryContainer.style.display = 'block';
	}

	var html = '';
	for (var i = 0; i < gameState.testResults.length; i++) {
		var result = gameState.testResults[i];
		var testInfo = FORENSIC_TESTS[result.testType];
		var testName = testInfo ? testInfo.name : result.testType;
		var sampleType = (result.sampleType || '').replace(/_/g, ' ');

		html += '<div class="sidebar-result-item">';
		html += '<strong>' + testName + '</strong>';
		html += '<br><span class="result-meta">' + sampleType + '</span>';
		html += '<br><span class="result-meta">' + getResultSummaryText(result) + '</span>';
		html += '</div>';
	}

	resultsList.innerHTML = html;
}

/* ============================================ */
/* gel_rendering.js */
/* ============================================ */

/* ============================================ */
/* GEL RENDERING - Canvas Gel Electrophoresis   */
/* ============================================ */

// Standard DNA size marker ladder values in base pairs
var LADDER_SIZES = [200, 500, 1000, 1500, 2000, 3000, 4000, 5000, 6000, 8000, 10000, 12000];

// Gel layout constants
var GEL_MARGIN_LEFT = 40;
var GEL_MARGIN_RIGHT = 20;
var GEL_MARGIN_TOP = 50;
var GEL_MARGIN_BOTTOM = 30;
var GEL_BG_COLOR = '#1a1a3e';
var GEL_AREA_COLOR = '#252560';
var BAND_COLOR_R = 136;
var BAND_COLOR_G = 187;
var BAND_COLOR_B = 255;

// Scale range for logarithmic band positioning
var GEL_MIN_SIZE = 200;
var GEL_MAX_SIZE = 15000;

/* ============================================ */
function sizeToY(size, gelTop, gelHeight) {
	/* Convert a DNA fragment size in bp to a vertical Y position
	   on the gel canvas. Larger fragments migrate less and appear
	   near the top; smaller fragments migrate further and appear
	   near the bottom. Uses logarithmic scaling.

	Args:
		size: fragment size in base pairs
		gelTop: pixel Y coordinate of the top of the gel area
		gelHeight: pixel height of the gel area

	Returns:
		number: Y coordinate in canvas pixels
	*/
	// Clamp size to the display range
	var clampedSize = Math.max(GEL_MIN_SIZE, Math.min(GEL_MAX_SIZE, size));
	// Logarithmic interpolation: large at top, small at bottom
	var logRange = Math.log(GEL_MAX_SIZE) - Math.log(GEL_MIN_SIZE);
	var fraction = (Math.log(clampedSize) - Math.log(GEL_MIN_SIZE)) / logRange;
	// Invert so large fragments are at the top
	var y = gelTop + gelHeight * (1.0 - fraction);
	return y;
}

/* ============================================ */
function drawBand(ctx, x, y, width, height, intensity) {
	/* Draw a single gel electrophoresis band with a glow effect.

	Args:
		ctx: canvas 2D rendering context
		x: left edge X coordinate of the band
		y: center Y coordinate of the band
		width: band width in pixels
		height: band height in pixels (typically 3-6)
		intensity: brightness from 0.0 to 1.0
	*/
	// Clamp intensity to valid range
	var alpha = Math.max(0.1, Math.min(1.0, intensity));

	// Outer glow effect using canvas shadow
	ctx.save();
	ctx.shadowColor = 'rgba(' + BAND_COLOR_R + ',' + BAND_COLOR_G + ',' + BAND_COLOR_B + ',' + (alpha * 0.6) + ')';
	ctx.shadowBlur = 6;
	ctx.shadowOffsetX = 0;
	ctx.shadowOffsetY = 0;

	// Draw the band rectangle
	ctx.fillStyle = 'rgba(' + BAND_COLOR_R + ',' + BAND_COLOR_G + ',' + BAND_COLOR_B + ',' + alpha + ')';
	ctx.fillRect(x, y - height / 2, width, height);

	ctx.restore();

	// Draw a brighter center line for sharper visual definition
	var centerAlpha = Math.min(1.0, alpha + 0.2);
	ctx.fillStyle = 'rgba(200, 220, 255, ' + centerAlpha + ')';
	ctx.fillRect(x + 2, y - 1, width - 4, 2);
}

/* ============================================ */
function drawLadder(ctx, x, gelTop, gelHeight, wellWidth) {
	/* Draw the DNA size marker ladder in the leftmost lane.
	   Draws thin bands at each standard size position and labels
	   each band with its size on the left margin.

	Args:
		ctx: canvas 2D rendering context
		x: center X coordinate of the ladder lane
		gelTop: pixel Y of the top of the gel area
		gelHeight: pixel height of the gel area
		wellWidth: width of each lane in pixels
	*/
	var bandWidth = wellWidth * 0.6;
	var bandX = x - bandWidth / 2;

	ctx.font = '9px monospace';
	ctx.fillStyle = '#8899bb';
	ctx.textAlign = 'right';

	for (var i = 0; i < LADDER_SIZES.length; i++) {
		var size = LADDER_SIZES[i];
		var y = sizeToY(size, gelTop, gelHeight);

		// Draw ladder band (thinner than sample bands)
		drawBand(ctx, bandX, y, bandWidth, 3, 0.7);

		// Draw size label on the left margin
		var labelText = '';
		if (size >= 1000) {
			labelText = (size / 1000) + 'kb';
		} else {
			labelText = size + 'bp';
		}
		ctx.fillStyle = '#8899bb';
		ctx.fillText(labelText, GEL_MARGIN_LEFT - 4, y + 3);
	}
}

/* ============================================ */
function drawWell(ctx, x, y, width) {
	/* Draw a sample well marker at the top of a gel lane.

	Args:
		ctx: canvas 2D rendering context
		x: center X coordinate of the well
		y: Y coordinate of the top of the gel area
		width: width of the well in pixels
	*/
	var wellWidth = width * 0.5;
	var wellHeight = 6;

	ctx.fillStyle = '#0a0a2a';
	ctx.fillRect(x - wellWidth / 2, y - wellHeight, wellWidth, wellHeight);

	// Draw a thin border around the well
	ctx.strokeStyle = '#334';
	ctx.lineWidth = 1;
	ctx.strokeRect(x - wellWidth / 2, y - wellHeight, wellWidth, wellHeight);
}

/* ============================================ */
function renderGel(canvasId, lanes, title) {
	/* Main gel rendering function. Draws a complete gel electrophoresis
	   image on the specified canvas element.

	Args:
		canvasId: ID of the canvas element (default 'gel-canvas')
		lanes: array of objects with the shape:
			{ label: string, fragments: [sizes in bp], intensity: number }
		title: string displayed at the top of the gel

	The first lane in the array should be the size marker ladder
	data, or an explicit ladder lane is prepended if lane[0].label
	is not 'Ladder'.
	*/
	if (!canvasId) {
		canvasId = 'gel-canvas';
	}
	var canvas = document.getElementById(canvasId);
	if (!canvas) {
		return;
	}

	// Force canvas dimensions
	canvas.width = 700;
	canvas.height = 450;
	var ctx = canvas.getContext('2d');

	// Calculate gel area dimensions
	var gelLeft = GEL_MARGIN_LEFT;
	var gelTop = GEL_MARGIN_TOP;
	var gelWidth = canvas.width - GEL_MARGIN_LEFT - GEL_MARGIN_RIGHT;
	var gelHeight = canvas.height - GEL_MARGIN_TOP - GEL_MARGIN_BOTTOM;

	// Prepend ladder lane if not already present
	var allLanes = [];
	if (lanes.length === 0 || lanes[0].label !== 'Ladder') {
		allLanes.push({ label: 'Ladder', fragments: LADDER_SIZES.slice(), intensity: 0.7 });
	}
	for (var i = 0; i < lanes.length; i++) {
		allLanes.push(lanes[i]);
	}

	// Calculate lane spacing
	var numLanes = allLanes.length;
	var laneWidth = gelWidth / numLanes;

	// Step 1: Fill background
	ctx.fillStyle = GEL_BG_COLOR;
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	// Step 2: Draw the gel area rectangle
	ctx.fillStyle = GEL_AREA_COLOR;
	ctx.fillRect(gelLeft, gelTop, gelWidth, gelHeight);

	// Draw thin gel border
	ctx.strokeStyle = '#334466';
	ctx.lineWidth = 1;
	ctx.strokeRect(gelLeft, gelTop, gelWidth, gelHeight);

	// Step 3: Draw lane separator lines
	ctx.strokeStyle = 'rgba(50, 60, 90, 0.4)';
	ctx.lineWidth = 1;
	for (var laneIdx = 1; laneIdx < numLanes; laneIdx++) {
		var separatorX = gelLeft + laneIdx * laneWidth;
		ctx.beginPath();
		ctx.moveTo(separatorX, gelTop);
		ctx.lineTo(separatorX, gelTop + gelHeight);
		ctx.stroke();
	}

	// Step 4: Draw wells and bands for each lane
	for (var laneNum = 0; laneNum < numLanes; laneNum++) {
		var lane = allLanes[laneNum];
		var laneCenterX = gelLeft + laneNum * laneWidth + laneWidth / 2;

		// Draw the well at the top
		drawWell(ctx, laneCenterX, gelTop, laneWidth);

		// Draw bands for this lane
		var bandWidth = laneWidth * 0.55;
		var bandX = laneCenterX - bandWidth / 2;
		var laneIntensity = (lane.intensity !== undefined) ? lane.intensity : 0.9;

		if (laneNum === 0 && lane.label === 'Ladder') {
			// Use the dedicated ladder drawing function
			drawLadder(ctx, laneCenterX, gelTop, gelHeight, laneWidth);
		} else {
			// Draw sample bands
			var fragments = lane.fragments || [];
			for (var fragIdx = 0; fragIdx < fragments.length; fragIdx++) {
				var fragSize = fragments[fragIdx];
				var bandY = sizeToY(fragSize, gelTop, gelHeight);
				// Slight variation in band thickness for realism
				var bandHeight = 4 + Math.random() * 2;
				drawBand(ctx, bandX, bandY, bandWidth, bandHeight, laneIntensity);
			}
		}
	}

	// Step 5: Draw lane labels at top
	ctx.font = 'bold 10px sans-serif';
	ctx.textAlign = 'center';
	ctx.fillStyle = '#aabbdd';
	for (var labelIdx = 0; labelIdx < numLanes; labelIdx++) {
		var labelX = gelLeft + labelIdx * laneWidth + laneWidth / 2;
		var labelY = gelTop - 10;
		var labelText = allLanes[labelIdx].label || ('Lane ' + (labelIdx + 1));
		// Truncate long labels
		if (labelText.length > 12) {
			labelText = labelText.substring(0, 11) + '...';
		}
		ctx.fillText(labelText, labelX, labelY);
	}

	// Step 6: Draw title at the very top
	if (title) {
		ctx.font = 'bold 14px sans-serif';
		ctx.textAlign = 'center';
		ctx.fillStyle = '#ccddff';
		ctx.fillText(title, canvas.width / 2, 18);
	}

	// Step 7: Draw a subtle gradient overlay at the bottom for depth
	var gradient = ctx.createLinearGradient(0, gelTop + gelHeight - 20, 0, gelTop + gelHeight);
	gradient.addColorStop(0, 'rgba(10, 10, 30, 0)');
	gradient.addColorStop(1, 'rgba(10, 10, 30, 0.3)');
	ctx.fillStyle = gradient;
	ctx.fillRect(gelLeft, gelTop + gelHeight - 20, gelWidth, 20);
}

/* ============================================ */
function renderRestrictionGel(canvasId, sampleFragments, suspectFragments, enzyme) {
	/* Render a simplified gel for restriction enzyme digest analysis.
	   Shows a ladder lane, the evidence sample lane, and one or more
	   suspect reference lanes.

	Args:
		canvasId: ID of the canvas element
		sampleFragments: array of fragment sizes (bp) for the evidence sample
		suspectFragments: object mapping suspect names to fragment arrays,
			e.g. { 'Ted Bundy': [800, 1500, 3000], ... }
		enzyme: name of the restriction enzyme used (for the title)
	*/
	var lanes = [];

	// Evidence sample lane
	lanes.push({
		label: 'Evidence',
		fragments: sampleFragments,
		intensity: 0.9
	});

	// Suspect reference lanes
	var suspectNames = Object.keys(suspectFragments);
	for (var i = 0; i < suspectNames.length; i++) {
		var name = suspectNames[i];
		// Use first name only for compact label
		var shortName = name.split(' ')[0];
		lanes.push({
			label: shortName,
			fragments: suspectFragments[name],
			intensity: 0.85
		});
	}

	var gelTitle = 'Restriction Digest - ' + enzyme;
	renderGel(canvasId, lanes, gelTitle);
}

/* ============================================ */
function renderSTRChart(canvasId, strData, title) {
	/* Draw an STR electropherogram-style bar chart showing allele
	   peaks grouped by locus. Each locus shows one or two peaks
	   at the corresponding repeat number positions.

	Args:
		canvasId: ID of the canvas element (default 'gel-canvas')
		strData: object mapping locus names to allele arrays,
			e.g. { 'D3S1358': [14, 16], 'vWA': [17, 19], ... }
		title: chart title string
	*/
	if (!canvasId) {
		canvasId = 'gel-canvas';
	}
	var canvas = document.getElementById(canvasId);
	if (!canvas) {
		return;
	}

	canvas.width = 700;
	canvas.height = 450;
	var ctx = canvas.getContext('2d');

	// Chart area constants
	var chartLeft = 60;
	var chartTop = 50;
	var chartRight = 680;
	var chartBottom = 400;
	var chartWidth = chartRight - chartLeft;
	var chartHeight = chartBottom - chartTop;

	// Color palette for locus groups
	var locusColors = [
		'#4488ff', '#44cc88', '#ff8844', '#cc44ff',
		'#ffcc44', '#44dddd', '#ff4488', '#88ff44'
	];

	// Gather locus names
	var lociNames = Object.keys(strData);
	var numLoci = lociNames.length;
	if (numLoci === 0) {
		return;
	}

	// Background
	ctx.fillStyle = '#0d0d2b';
	ctx.fillRect(0, 0, canvas.width, canvas.height);

	// Chart background
	ctx.fillStyle = '#141438';
	ctx.fillRect(chartLeft, chartTop, chartWidth, chartHeight);

	// Draw title
	if (title) {
		ctx.font = 'bold 14px sans-serif';
		ctx.textAlign = 'center';
		ctx.fillStyle = '#ccddff';
		ctx.fillText(title, canvas.width / 2, 24);
	}

	// Y-axis label
	ctx.save();
	ctx.translate(16, chartTop + chartHeight / 2);
	ctx.rotate(-Math.PI / 2);
	ctx.font = '11px sans-serif';
	ctx.textAlign = 'center';
	ctx.fillStyle = '#8899bb';
	ctx.fillText('Relative Fluorescence (RFU)', 0, 0);
	ctx.restore();

	// Y-axis gridlines
	ctx.strokeStyle = 'rgba(80, 100, 140, 0.3)';
	ctx.lineWidth = 1;
	for (var gridIdx = 0; gridIdx <= 4; gridIdx++) {
		var gridY = chartTop + (chartHeight * gridIdx / 4);
		ctx.beginPath();
		ctx.moveTo(chartLeft, gridY);
		ctx.lineTo(chartRight, gridY);
		ctx.stroke();
	}

	// Calculate locus group widths
	var locusGroupWidth = chartWidth / numLoci;

	for (var locIdx = 0; locIdx < numLoci; locIdx++) {
		var locusName = lociNames[locIdx];
		var alleles = strData[locusName];
		var color = locusColors[locIdx % locusColors.length];
		var groupLeft = chartLeft + locIdx * locusGroupWidth;
		var groupCenter = groupLeft + locusGroupWidth / 2;

		// Draw locus separator line
		if (locIdx > 0) {
			ctx.strokeStyle = 'rgba(60, 70, 100, 0.5)';
			ctx.lineWidth = 1;
			ctx.setLineDash([3, 3]);
			ctx.beginPath();
			ctx.moveTo(groupLeft, chartTop);
			ctx.lineTo(groupLeft, chartBottom);
			ctx.stroke();
			ctx.setLineDash([]);
		}

		// Draw locus name label at bottom
		ctx.font = 'bold 9px sans-serif';
		ctx.textAlign = 'center';
		ctx.fillStyle = color;
		ctx.fillText(locusName, groupCenter, chartBottom + 16);

		// Draw allele peaks
		if (!alleles || alleles.length === 0) {
			continue;
		}

		var peakWidth = Math.max(8, locusGroupWidth / 5);
		var peakSpacing = peakWidth + 6;

		// Center the peaks within the group
		var totalPeakWidth = alleles.length * peakSpacing - 6;
		var peakStartX = groupCenter - totalPeakWidth / 2;

		for (var alleleIdx = 0; alleleIdx < alleles.length; alleleIdx++) {
			var alleleValue = alleles[alleleIdx];
			// Simulate peak height (random variation for realism)
			var peakHeightFraction = 0.6 + Math.random() * 0.35;
			var peakHeight = chartHeight * peakHeightFraction;
			var peakX = peakStartX + alleleIdx * peakSpacing;
			var peakY = chartBottom - peakHeight;

			// Draw peak as a filled triangle/curve
			ctx.beginPath();
			ctx.moveTo(peakX, chartBottom);
			// Left side of peak
			ctx.quadraticCurveTo(peakX + peakWidth * 0.25, peakY + peakHeight * 0.2, peakX + peakWidth / 2, peakY);
			// Right side of peak
			ctx.quadraticCurveTo(peakX + peakWidth * 0.75, peakY + peakHeight * 0.2, peakX + peakWidth, chartBottom);
			ctx.closePath();

			// Fill with semi-transparent color
			ctx.fillStyle = color;
			ctx.globalAlpha = 0.7;
			ctx.fill();
			ctx.globalAlpha = 1.0;

			// Draw peak outline
			ctx.strokeStyle = color;
			ctx.lineWidth = 1.5;
			ctx.beginPath();
			ctx.moveTo(peakX, chartBottom);
			ctx.quadraticCurveTo(peakX + peakWidth * 0.25, peakY + peakHeight * 0.2, peakX + peakWidth / 2, peakY);
			ctx.quadraticCurveTo(peakX + peakWidth * 0.75, peakY + peakHeight * 0.2, peakX + peakWidth, chartBottom);
			ctx.stroke();

			// Label the allele number at the peak top
			ctx.font = 'bold 10px monospace';
			ctx.textAlign = 'center';
			ctx.fillStyle = '#ffffff';
			ctx.fillText(String(alleleValue), peakX + peakWidth / 2, peakY - 6);
		}
	}

	// Draw X-axis baseline
	ctx.strokeStyle = '#667799';
	ctx.lineWidth = 1;
	ctx.beginPath();
	ctx.moveTo(chartLeft, chartBottom);
	ctx.lineTo(chartRight, chartBottom);
	ctx.stroke();

	// Draw Y-axis line
	ctx.beginPath();
	ctx.moveTo(chartLeft, chartTop);
	ctx.lineTo(chartLeft, chartBottom);
	ctx.stroke();
}

/* ============================================ */
function showGelInModal(lanes, title) {
	/* Render a gel on the hidden canvas and display the resulting
	   image in the game modal for a larger view.

	Args:
		lanes: array of lane objects for renderGel()
		title: gel title string
	*/
	var canvas = document.getElementById('gel-canvas');
	if (!canvas) {
		return;
	}

	// Make canvas visible temporarily for rendering
	canvas.style.display = 'block';
	renderGel('gel-canvas', lanes, title);

	// Capture the canvas content as a data URL image
	var imageUrl = canvas.toDataURL('image/png');
	canvas.style.display = 'none';

	// Build modal content with the gel image
	var modalHtml = '';
	modalHtml += '<h3>' + title + '</h3>';
	modalHtml += '<div style="text-align: center;">';
	modalHtml += '<img src="' + imageUrl + '" style="max-width: 100%; border: 1px solid #334466; border-radius: 4px;" alt="Gel electrophoresis result">';
	modalHtml += '</div>';
	modalHtml += '<p style="color: #8899bb; font-size: 0.85em; margin-top: 8px;">';
	modalHtml += 'Larger fragments (top) migrate less. Smaller fragments (bottom) migrate further through the gel.';
	modalHtml += '</p>';

	showModal('Gel Electrophoresis', modalHtml);
}

/* ============================================ */
function getGelAsImage() {
	/* Capture the current content of the gel canvas as a data URL
	   string for embedding in test results or saving.

	Returns:
		string: PNG data URL of the gel canvas content, or empty
			string if canvas is not available
	*/
	var canvas = document.getElementById('gel-canvas');
	if (!canvas) {
		return '';
	}
	return canvas.toDataURL('image/png');
}

/* ============================================ */
/* case_board.js */
/* ============================================ */

/* ============================================ */
/* SECTION 7: CASE BOARD PHASE                 */
/* ============================================ */

/* ============================================ */
function renderCaseBoard() {
	/*
	Renders the full case board UI into #main-panel.
	Shows evidence summary, suspect assessments,
	conclusion text area, and action buttons.
	*/
	var mainPanel = document.getElementById('main-panel');
	if (!mainPanel) {
		return;
	}

	var html = '';

	// -- Section 1: Evidence Summary Table --
	html += '<div class="case-board-section">';
	html += '<h2>Evidence Summary</h2>';
	html += buildEvidenceSummaryTable();
	html += '</div>';

	// -- Section 2: Suspect Assessment Cards --
	html += '<div class="case-board-section">';
	html += '<h2>Suspect Assessment</h2>';
	html += buildSuspectAssessmentCards();
	html += '</div>';

	// -- Section 3: Conclusion Text Area --
	html += '<div class="case-board-section">';
	html += '<h2>Forensic Conclusion</h2>';
	html += '<p class="form-hint">';
	html += 'Write your forensic conclusion. Use proper scientific language.';
	html += '</p>';
	html += '<textarea id="conclusion-textarea" ';
	html += 'class="conclusion-input" ';
	html += 'rows="6" ';
	html += 'placeholder="Based on the evidence collected..." ';
	html += 'onchange="updateConclusion(this.value)" ';
	html += 'oninput="updateConclusion(this.value)">';
	// Pre-fill with any saved conclusion text
	html += escapeHtml(gameState.currentConclusion);
	html += '</textarea>';
	html += '</div>';

	// -- Section 4: Action Buttons --
	html += '<div class="case-board-actions">';
	html += '<button class="btn btn-secondary" ';
	html += 'onclick="enterScenePhase()">';
	html += 'Continue Investigating';
	html += '</button>';

	// Only show accusation button if at least 1 test was run
	var testsRun = gameState.testResults.length;
	if (testsRun > 0) {
		html += '<button class="btn btn-accent" ';
		html += 'onclick="transitionTo(PHASE.ACCUSATION)">';
		html += 'Make Accusation';
		html += '</button>';
	}

	html += '<button class="btn btn-primary" ';
	html += 'onclick="endRound()">';
	html += 'End Round';
	html += '</button>';
	html += '</div>';

	mainPanel.innerHTML = html;
}

/* ============================================ */
function buildEvidenceSummaryTable() {
	/*
	Builds an HTML table summarizing all collected samples
	and their test results, with certainty dropdowns.
	Returns HTML string.
	*/
	var samples = gameState.collectedSamples;
	var results = gameState.testResults;

	// Show empty state if no samples collected
	if (samples.length === 0 && results.length === 0) {
		var emptyHtml = '<p class="empty-state">';
		emptyHtml += 'No evidence has been collected yet. ';
		emptyHtml += 'Return to the crime scene to gather samples.';
		emptyHtml += '</p>';
		return emptyHtml;
	}

	var html = '';
	html += '<table class="evidence-summary-table">';
	html += '<thead><tr>';
	html += '<th>Sample Label</th>';
	html += '<th>Type</th>';
	html += '<th>Test Run</th>';
	html += '<th>Result Summary</th>';
	html += '<th>Certainty</th>';
	html += '</tr></thead>';
	html += '<tbody>';

	// Build rows: one per test result, plus untested samples
	var testedSampleIds = {};
	for (var r = 0; r < results.length; r++) {
		var result = results[r];
		testedSampleIds[result.sampleId] = true;

		// Find the matching sample for this result
		var matchingSample = findSampleById(result.sampleId);
		var sampleLabel = matchingSample ? matchingSample.label : result.sampleId;
		var sampleType = matchingSample ? matchingSample.evidenceType : 'unknown';

		html += '<tr>';
		html += '<td>' + escapeHtml(sampleLabel) + '</td>';
		html += '<td>' + escapeHtml(sampleType.replace('_', ' ')) + '</td>';
		html += '<td>' + escapeHtml(result.testName) + '</td>';
		html += '<td>' + buildResultSummaryText(result) + '</td>';
		html += '<td>' + buildCertaintyDropdown(r) + '</td>';
		html += '</tr>';
	}

	// Add rows for samples that have not been tested yet
	for (var s = 0; s < samples.length; s++) {
		if (!testedSampleIds[samples[s].id]) {
			html += '<tr class="untested-row">';
			html += '<td>' + escapeHtml(samples[s].label) + '</td>';
			html += '<td>' + escapeHtml(samples[s].evidenceType.replace('_', ' ')) + '</td>';
			html += '<td>-- Not tested --</td>';
			html += '<td>--</td>';
			html += '<td>--</td>';
			html += '</tr>';
		}
	}

	html += '</tbody></table>';
	return html;
}

/* ============================================ */
function findSampleById(sampleId) {
	/*
	Searches gameState.collectedSamples for a sample matching
	the given ID string.
	Returns the sample object or null.
	*/
	for (var i = 0; i < gameState.collectedSamples.length; i++) {
		if (gameState.collectedSamples[i].id === sampleId) {
			return gameState.collectedSamples[i];
		}
	}
	return null;
}

/* ============================================ */
function buildResultSummaryText(result) {
	/*
	Generates a short human-readable summary of a test result.
	Returns an HTML string.
	Args:
		result: a test result object from gameState.testResults
	*/
	if (!result.success) {
		var errorText = '<span class="result-error">';
		if (result.data && result.data.error) {
			errorText += escapeHtml(result.data.error);
		} else {
			errorText += 'Test failed';
		}
		errorText += '</span>';
		return errorText;
	}

	var summary = '';

	// Add contamination warning if applicable
	if (result.contaminated) {
		summary += '<span class="result-warning">[CONTAMINATED] </span>';
	}

	// Build summary based on test type
	switch (result.testType) {
		case 'blood_type':
			if (result.data && result.data.bloodType) {
				summary += 'Blood Type: <strong>' + escapeHtml(result.data.bloodType) + '</strong>';
			}
			break;

		case 'rflp':
			if (result.data && result.data.enzymes) {
				var enzymeNames = Object.keys(result.data.enzymes);
				var bandCounts = [];
				for (var e = 0; e < enzymeNames.length; e++) {
					var fragCount = result.data.enzymes[enzymeNames[e]].length;
					bandCounts.push(enzymeNames[e] + ': ' + fragCount + ' bands');
				}
				summary += bandCounts.join(', ');
			}
			break;

		case 'str':
			if (result.data && result.data.loci) {
				var lociNames = Object.keys(result.data.loci);
				var activeLoci = 0;
				for (var l = 0; l < lociNames.length; l++) {
					if (result.data.loci[lociNames[l]].length > 0) {
						activeLoci++;
					}
				}
				summary += activeLoci + ' of ' + lociNames.length + ' loci detected';
			}
			break;

		case 'mtdna':
			if (result.data && result.data.haplotype) {
				summary += 'Haplotype: <strong>' + escapeHtml(result.data.haplotype) + '</strong>';
			}
			break;

		case 'restriction':
			if (result.data && result.data.fragments) {
				summary += result.data.enzyme + ': ';
				summary += result.data.fragments.length + ' fragments';
			}
			break;

		default:
			summary += 'Result available';
	}

	// Note if control was included
	if (result.controlIncluded) {
		summary += ' <span class="control-badge">[Control: OK]</span>';
	}

	return summary;
}

/* ============================================ */
function buildCertaintyDropdown(resultIndex) {
	/*
	Builds an HTML select dropdown for certainty level
	associated with a particular test result.
	Args:
		resultIndex: index into gameState.testResults
	Returns HTML string for the dropdown.
	*/
	var html = '<select class="certainty-select" ';
	html += 'onchange="setCertaintyLevel(' + resultIndex + ', this.value)">';
	html += '<option value="">-- Select --</option>';

	for (var c = 0; c < CERTAINTY_LEVELS.length; c++) {
		var level = CERTAINTY_LEVELS[c];
		html += '<option value="' + level.value + '" ';
		html += 'title="' + escapeHtml(level.description) + '">';
		html += escapeHtml(level.label);
		html += '</option>';
	}

	html += '</select>';
	return html;
}

/* ============================================ */
function setCertaintyLevel(resultIndex, certaintyValue) {
	/*
	Stores the player-selected certainty level for a test result.
	Args:
		resultIndex: index into gameState.testResults
		certaintyValue: string value from CERTAINTY_LEVELS
	*/
	if (resultIndex >= 0 && resultIndex < gameState.testResults.length) {
		gameState.testResults[resultIndex].playerCertainty = certaintyValue;
	}
}

/* ============================================ */
function buildSuspectAssessmentCards() {
	/*
	Builds HTML cards for each alive suspect with suspicion
	slider, notes text area, and evidence tags.
	Returns HTML string.
	*/
	var aliveSuspects = getAliveSuspects();

	if (aliveSuspects.length === 0) {
		return '<p class="empty-state">No living suspects remain.</p>';
	}

	var html = '<div class="suspect-assessment-grid">';

	for (var i = 0; i < aliveSuspects.length; i++) {
		var suspect = aliveSuspects[i];
		html += buildSingleSuspectCard(suspect);
	}

	html += '</div>';
	return html;
}

/* ============================================ */
function buildSingleSuspectCard(suspect) {
	/*
	Builds a single suspect assessment card with name, role,
	suspicion slider, notes area, and evidence tags.
	Args:
		suspect: a suspect character object
	Returns HTML string.
	*/
	// Retrieve saved notes for this suspect
	var savedNotes = '';
	var savedSuspicion = 50;
	var notesData = gameState.suspectNotes[suspect.id];
	if (notesData && typeof notesData === 'object') {
		savedNotes = notesData.notes || '';
		savedSuspicion = notesData.suspicion || 50;
	} else if (typeof notesData === 'string') {
		savedNotes = notesData;
	}

	var html = '';
	html += '<div class="suspect-assessment-card" data-suspect-id="' + suspect.id + '">';

	// Name and role header
	html += '<div class="suspect-card-header">';
	html += '<h3>' + escapeHtml(suspect.name) + '</h3>';
	html += '<p class="suspect-role">' + escapeHtml(suspect.role) + '</p>';
	html += '</div>';

	// Suspicion slider (0-100)
	html += '<div class="suspicion-slider-group">';
	html += '<label>Suspicion Level: ';
	html += '<span id="suspicion-value-' + suspect.id + '">' + savedSuspicion + '</span>%';
	html += '</label>';
	html += '<input type="range" ';
	html += 'class="suspicion-slider" ';
	html += 'min="0" max="100" ';
	html += 'value="' + savedSuspicion + '" ';
	html += 'oninput="onSuspicionSliderChange(\'' + suspect.id + '\', this.value)">';
	html += '</div>';

	// Notes text area
	html += '<div class="suspect-notes-group">';
	html += '<label>Investigator Notes:</label>';
	html += '<textarea class="suspect-notes" ';
	html += 'rows="3" ';
	html += 'placeholder="Record observations about this suspect..." ';
	html += 'oninput="updateSuspectAssessment(\'' + suspect.id + '\', \'notes\', this.value)">';
	html += escapeHtml(savedNotes);
	html += '</textarea>';
	html += '</div>';

	// Evidence tags linking to test results involving this suspect
	html += '<div class="evidence-tags">';
	html += buildEvidenceTagsForSuspect(suspect.id);
	html += '</div>';

	html += '</div>';
	return html;
}

/* ============================================ */
function onSuspicionSliderChange(suspectId, value) {
	/*
	Handles the suspicion slider input event. Updates the
	displayed value and stores it in gameState.
	Args:
		suspectId: string ID of the suspect
		value: string slider value (0-100)
	*/
	// Update the displayed percentage
	var valueSpan = document.getElementById('suspicion-value-' + suspectId);
	if (valueSpan) {
		valueSpan.textContent = value;
	}

	// Store in game state
	updateSuspectAssessment(suspectId, 'suspicion', parseInt(value, 10));
}

/* ============================================ */
function buildEvidenceTagsForSuspect(suspectId) {
	/*
	Finds test results that may relate to a suspect and
	renders them as small tag badges.
	Args:
		suspectId: string ID of the suspect
	Returns HTML string with evidence tag badges.
	*/
	var results = gameState.testResults;
	var tags = '';
	var tagCount = 0;

	for (var i = 0; i < results.length; i++) {
		var result = results[i];
		// Find the sample this result belongs to
		var sample = findSampleById(result.sampleId);
		if (!sample) {
			continue;
		}

		// Check if the evidence source matches this suspect
		// (the player does not know the source, but we show the test name)
		tags += '<span class="evidence-tag-badge">';
		tags += escapeHtml(result.testName);
		tags += ' (' + escapeHtml(sample.label) + ')';
		tags += '</span>';
		tagCount++;
	}

	if (tagCount === 0) {
		tags = '<span class="empty-state-inline">No linked evidence</span>';
	}

	return tags;
}

/* ============================================ */
function updateSuspectAssessment(suspectId, field, value) {
	/*
	Updates gameState.suspectNotes for a specific suspect.
	Args:
		suspectId: string ID of the suspect
		field: 'suspicion' (slider value) or 'notes' (text)
		value: the new value to store
	*/
	// Initialize notes object if it is still a plain string
	if (typeof gameState.suspectNotes[suspectId] !== 'object') {
		var oldNotes = gameState.suspectNotes[suspectId] || '';
		gameState.suspectNotes[suspectId] = {
			suspicion: 50,
			notes: oldNotes
		};
	}

	if (field === 'suspicion') {
		gameState.suspectNotes[suspectId].suspicion = value;
	} else if (field === 'notes') {
		gameState.suspectNotes[suspectId].notes = value;
	}
}

/* ============================================ */
function updateConclusion(text) {
	/*
	Saves the player's conclusion text to gameState.
	Args:
		text: string from the conclusion textarea
	*/
	gameState.currentConclusion = text;
}

/* ============================================ */
function renderAccusation() {
	/*
	Renders the accusation screen into #accusation-content.
	Shows all alive suspects as clickable cards with a
	"Who is the killer?" prompt. Clicking a suspect shows
	a confirmation dialog before finalizing.
	*/
	var container = document.getElementById('accusation-content');
	if (!container) {
		return;
	}

	var aliveSuspects = getAliveSuspects();

	var html = '';
	html += '<div class="accusation-prompt">';
	html += '<h3>Who is the killer?</h3>';
	html += '<p>Review the evidence carefully. This decision is final.</p>';
	html += '</div>';

	html += '<div class="accusation-grid">';
	for (var i = 0; i < aliveSuspects.length; i++) {
		var suspect = aliveSuspects[i];
		html += '<div class="accusation-card" ';
		html += 'onclick="confirmAccusation(\'' + suspect.id + '\')">';
		html += '<h3>' + escapeHtml(suspect.name) + '</h3>';
		html += '<p class="suspect-role">' + escapeHtml(suspect.role) + '</p>';
		html += '<p class="suspect-alibi">' + escapeHtml(suspect.alibi) + '</p>';
		html += '<p class="suspect-motive"><strong>Motive:</strong> ';
		html += escapeHtml(suspect.motive) + '</p>';
		html += '</div>';
	}
	html += '</div>';

	// Back button to return to case board
	html += '<div class="accusation-actions">';
	html += '<button class="btn btn-secondary" ';
	html += 'onclick="enterCaseBoard()">';
	html += 'Go Back to Case Board';
	html += '</button>';
	html += '</div>';

	container.innerHTML = html;
}

/* ============================================ */
function confirmAccusation(suspectId) {
	/*
	Shows a confirmation dialog before finalizing an accusation.
	Args:
		suspectId: string ID of the suspect being accused
	*/
	var suspect = getSuspectById(suspectId);
	if (!suspect) {
		return;
	}

	var dialogHtml = '';
	dialogHtml += '<p>You are about to accuse:</p>';
	dialogHtml += '<h3>' + escapeHtml(suspect.name) + '</h3>';
	dialogHtml += '<p><strong>This action cannot be undone.</strong></p>';
	dialogHtml += '<p>Are you sure this person is the killer?</p>';
	dialogHtml += '<div class="confirmation-buttons">';
	dialogHtml += '<button class="btn btn-accent" ';
	dialogHtml += 'onclick="closeModal(); makeAccusation(\'' + suspectId + '\')">';
	dialogHtml += 'Yes, I am certain';
	dialogHtml += '</button>';
	dialogHtml += '<button class="btn btn-secondary" ';
	dialogHtml += 'onclick="closeModal()">';
	dialogHtml += 'No, let me reconsider';
	dialogHtml += '</button>';
	dialogHtml += '</div>';

	showModal('Confirm Accusation', dialogHtml);
}

/* ============================================ */
function renderRoundEnd() {
	/*
	Renders the round end score breakdown into #round-score-content.
	Shows a score card for each category with points earned and
	max possible. Color codes positive (green) and negative (red)
	values. Displays total round score prominently.
	*/
	var container = document.getElementById('round-score-content');
	if (!container) {
		return;
	}

	var roundScore = gameState.roundScores[gameState.roundScores.length - 1];
	if (!roundScore) {
		container.innerHTML = '<p>Error: No score data available.</p>';
		return;
	}

	var html = '';
	html += '<h2>Round ' + gameState.round + ' Complete</h2>';

	html += '<div class="score-card">';
	html += '<table class="score-breakdown-table">';
	html += '<thead><tr>';
	html += '<th>Category</th>';
	html += '<th>Points Earned</th>';
	html += '<th>Max Possible</th>';
	html += '</tr></thead>';
	html += '<tbody>';

	// Score categories with display names
	var categories = [
		{ key: 'sampleHandling', name: 'Sample Handling', max: SCORE_WEIGHTS.sampleHandling },
		{ key: 'chainOfCustody', name: 'Chain of Custody', max: SCORE_WEIGHTS.chainOfCustody },
		{ key: 'testSelection', name: 'Test Selection', max: SCORE_WEIGHTS.testSelection },
		{ key: 'controlUsage', name: 'Control Usage', max: SCORE_WEIGHTS.controlUsage },
		{ key: 'interpretation', name: 'Interpretation', max: SCORE_WEIGHTS.interpretation },
		{ key: 'conclusionQuality', name: 'Conclusion Quality', max: SCORE_WEIGHTS.conclusionQuality },
		{ key: 'contaminationPenalty', name: 'Contamination Penalty', max: SCORE_WEIGHTS.contaminationPenalty },
		{ key: 'efficiencyBonus', name: 'Efficiency Bonus', max: SCORE_WEIGHTS.efficiencyBonus }
	];

	for (var i = 0; i < categories.length; i++) {
		var cat = categories[i];
		var earned = roundScore[cat.key] || 0;
		var colorClass = 'score-neutral';
		if (earned > 0) {
			colorClass = 'score-positive';
		} else if (earned < 0) {
			colorClass = 'score-negative';
		}

		html += '<tr class="' + colorClass + '">';
		html += '<td>' + cat.name + '</td>';
		html += '<td>' + earned + '</td>';
		html += '<td>' + cat.max + '</td>';
		html += '</tr>';
	}

	html += '</tbody></table>';

	// Total score row
	html += '<div class="round-total">';
	html += '<strong>Round Total: ' + roundScore.total + '</strong>';
	html += ' / ' + roundScore.maxPossible + ' possible';
	html += '</div>';
	html += '</div>';

	// Cumulative score
	html += '<div class="cumulative-score">';
	html += '<p>Cumulative Score: <strong>' + gameState.totalScore + '</strong></p>';
	html += '</div>';

	// Action buttons
	html += '<div class="round-end-actions">';

	// Check if game should continue or force final accusation
	var remaining = getAliveSuspects();
	if (remaining.length <= 2) {
		html += '<button class="btn btn-accent" ';
		html += 'onclick="transitionTo(PHASE.ACCUSATION)">';
		html += 'Make Final Accusation';
		html += '</button>';
	} else {
		html += '<button class="btn btn-primary" ';
		html += 'onclick="advanceToNextRound()">';
		html += 'Next Round';
		html += '</button>';
		html += '<button class="btn btn-accent" ';
		html += 'onclick="transitionTo(PHASE.ACCUSATION)">';
		html += 'Make Final Accusation';
		html += '</button>';
	}
	html += '</div>';

	container.innerHTML = html;
}

/* ============================================ */
function renderGameOver() {
	/*
	Renders the game over screen into #game-over-content.
	Shows accusation result reveal, final score breakdown
	across all rounds, letter grade, educational summary,
	methodology feedback, and a Play Again button.
	*/
	var container = document.getElementById('game-over-content');
	if (!container) {
		return;
	}

	var html = '';

	// -- 1. Dramatic accusation reveal --
	var isCorrect = false;
	if (gameState.accusedSuspect && gameState.killer) {
		isCorrect = (gameState.accusedSuspect.id === gameState.killer.id);
	}

	html += '<div class="game-over-reveal">';
	html += '<h2>Case Closed</h2>';
	html += '<div class="killer-reveal">';
	html += '<p class="reveal-label">The killer was:</p>';
	html += '<h3 class="killer-name">' + escapeHtml(gameState.killer.name) + '</h3>';
	html += '<p class="killer-role">' + escapeHtml(gameState.killer.role) + '</p>';
	html += '<p class="killer-motive"><strong>Motive:</strong> ';
	html += escapeHtml(gameState.killer.motive) + '</p>';
	html += '</div>';

	if (isCorrect) {
		html += '<div class="verdict verdict-correct">';
		html += '<h3>Correct!</h3>';
		html += '<p>Your forensic analysis led to the right conclusion. ';
		html += 'Justice has been served.</p>';
		html += '</div>';
	} else {
		html += '<div class="verdict verdict-wrong">';
		html += '<h3>Incorrect</h3>';
		html += '<p>You accused <strong>';
		html += escapeHtml(gameState.accusedSuspect.name);
		html += '</strong>, but the real killer was <strong>';
		html += escapeHtml(gameState.killer.name);
		html += '</strong>.</p>';
		html += '<p>Review the evidence more carefully next time.</p>';
		html += '</div>';
	}
	html += '</div>';

	// -- 2. Final score breakdown across all rounds --
	var finalScore = calculateFinalScore();

	html += '<div class="final-score-section">';
	html += '<h2>Final Score Breakdown</h2>';
	html += '<table class="final-score-table">';
	html += '<thead><tr>';
	html += '<th>Round</th>';
	html += '<th>Score</th>';
	html += '<th>Samples</th>';
	html += '<th>Tests</th>';
	html += '</tr></thead>';
	html += '<tbody>';

	for (var r = 0; r < gameState.roundHistory.length; r++) {
		var rh = gameState.roundHistory[r];
		html += '<tr>';
		html += '<td>Round ' + rh.round + '</td>';
		html += '<td>' + rh.score.total + '</td>';
		html += '<td>' + rh.samplesCollected + '</td>';
		html += '<td>' + rh.testsRun + '</td>';
		html += '</tr>';
	}

	html += '</tbody></table>';

	// Accusation bonus/penalty row
	html += '<div class="accusation-score">';
	html += '<p>Accusation Bonus: <strong>';
	html += finalScore.accusationBonus + '</strong></p>';
	html += '</div>';
	html += '</div>';

	// -- 3. Total score and letter grade --
	var letterGrade = getLetterGrade(finalScore.total, finalScore.maxPossible);

	html += '<div class="total-score-display">';
	html += '<div class="letter-grade grade-' + letterGrade + '">';
	html += letterGrade;
	html += '</div>';
	html += '<div class="total-score-number">';
	html += '<p>Final Score: <strong>' + finalScore.total + '</strong>';
	html += ' / ' + finalScore.maxPossible + '</p>';
	html += '</div>';
	html += '</div>';

	// -- 4. Educational summary --
	html += '<div class="educational-summary">';
	html += '<h2>Forensic Science Summary</h2>';
	html += getEndGameSummary();
	html += '</div>';

	// -- 5. Methodology feedback --
	html += '<div class="methodology-feedback">';
	html += '<h2>Scientific Methodology Review</h2>';
	html += buildMethodologyFeedback(finalScore);
	html += '</div>';

	// -- 6. Play Again button --
	html += '<div class="game-over-actions">';
	html += '<button class="btn btn-primary" ';
	html += 'onclick="showSetupScreen()">';
	html += 'Play Again';
	html += '</button>';
	html += '</div>';

	container.innerHTML = html;
}

/* ============================================ */
function buildMethodologyFeedback(finalScore) {
	/*
	Generates feedback text about the player's scientific
	methodology based on their scoring patterns.
	Args:
		finalScore: result object from calculateFinalScore()
	Returns HTML string with feedback paragraphs.
	*/
	var html = '';
	var strengths = [];
	var improvements = [];

	// Analyze round score averages
	var roundCount = gameState.roundHistory.length;
	if (roundCount === 0) {
		return '<p>No rounds completed for analysis.</p>';
	}

	// Sum up category scores across rounds
	var totals = {
		sampleHandling: 0,
		chainOfCustody: 0,
		testSelection: 0,
		controlUsage: 0,
		interpretation: 0,
		conclusionQuality: 0,
		contaminationPenalty: 0,
		efficiencyBonus: 0
	};

	for (var r = 0; r < gameState.roundScores.length; r++) {
		var rs = gameState.roundScores[r];
		var keys = Object.keys(totals);
		for (var k = 0; k < keys.length; k++) {
			totals[keys[k]] += (rs[keys[k]] || 0);
		}
	}

	// Evaluate each area
	if (totals.sampleHandling > roundCount * 5) {
		strengths.push('Excellent evidence handling technique');
	} else {
		improvements.push('Practice proper evidence handling -- always wear gloves');
	}

	if (totals.chainOfCustody > roundCount * 5) {
		strengths.push('Strong chain of custody documentation');
	} else {
		improvements.push('Improve sample labeling and chain of custody records');
	}

	if (totals.testSelection > roundCount * 7) {
		strengths.push('Good test selection for sample types');
	} else {
		improvements.push('Choose tests that match your sample types more carefully');
	}

	if (totals.controlUsage > roundCount * 7) {
		strengths.push('Consistent use of experimental controls');
	} else {
		improvements.push('Always include positive and negative controls in your tests');
	}

	if (totals.interpretation > roundCount * 10) {
		strengths.push('Strong scientific interpretation of results');
	} else {
		improvements.push('Use more careful, evidence-based language in interpretations');
	}

	if (totals.conclusionQuality > roundCount * 10) {
		strengths.push('Well-reasoned forensic conclusions');
	} else {
		improvements.push('Write more thorough conclusions citing specific evidence');
	}

	if (totals.contaminationPenalty < 0) {
		improvements.push('Reduce contamination events by putting on gloves before collecting');
	}

	// Build output
	if (strengths.length > 0) {
		html += '<h3>Strengths</h3><ul>';
		for (var s = 0; s < strengths.length; s++) {
			html += '<li>' + strengths[s] + '</li>';
		}
		html += '</ul>';
	}

	if (improvements.length > 0) {
		html += '<h3>Areas for Improvement</h3><ul>';
		for (var m = 0; m < improvements.length; m++) {
			html += '<li>' + improvements[m] + '</li>';
		}
		html += '</ul>';
	}

	return html;
}

/* ============================================ */
function getLetterGrade(totalScore, maxPossibleScore) {
	/*
	Returns a letter grade based on percentage of max score.
	A: 90%+, B: 80-89%, C: 70-79%, D: 60-69%, F: below 60%
	Args:
		totalScore: numeric total score earned
		maxPossibleScore: numeric max possible score
	Returns single letter string: A, B, C, D, or F.
	*/
	// Avoid division by zero
	if (maxPossibleScore <= 0) {
		return 'F';
	}

	var percentage = (totalScore / maxPossibleScore) * 100;

	if (percentage >= 90) {
		return 'A';
	}
	if (percentage >= 80) {
		return 'B';
	}
	if (percentage >= 70) {
		return 'C';
	}
	if (percentage >= 60) {
		return 'D';
	}
	return 'F';
}

/* ============================================ */
/* scoring.js */
/* ============================================ */

/* ============================================ */
/* SECTION 8: SCORING ENGINE                   */
/* ============================================ */

// Scientific language keywords for interpretation scoring
var GOOD_SCIENCE_KEYWORDS = [
	'consistent with', 'match', 'exclude', 'pattern',
	'supports', 'indicates', 'correlates', 'compatible'
];

var CAUTIOUS_SCIENCE_KEYWORDS = [
	'inconclusive', 'further testing', 'partial', 'degraded',
	'insufficient', 'cannot determine', 'limited', 'possible'
];

var OVERCLAIMING_KEYWORDS = [
	'definitely', 'proves', '100%', 'certainly',
	'without a doubt', 'guaranteed', 'absolute', 'undeniable',
	'no question', 'obviously'
];

var EVIDENCE_REFERENCE_KEYWORDS = [
	'sample', 'blood', 'dna', 'hair', 'saliva', 'fiber',
	'fragment', 'locus', 'loci', 'allele', 'band', 'haplotype',
	'type', 'profile', 'result', 'test'
];

var REASONING_KEYWORDS = [
	'because', 'therefore', 'however', 'although',
	'suggests', 'indicates', 'based on', 'given that',
	'considering', 'while', 'since', 'combined with'
];

var UNCERTAINTY_KEYWORDS = [
	'likely', 'unlikely', 'probable', 'possible',
	'may', 'might', 'could', 'suggests',
	'consistent with', 'cannot exclude', 'appears to'
];

/* ============================================ */
function calculateRoundScore() {
	/*
	Evaluates the player's work this round and returns
	a score object with all categories and total.
	Scoring rewards scientific rigor, not just correct answers.
	Returns: {
		sampleHandling, chainOfCustody, testSelection,
		controlUsage, interpretation, conclusionQuality,
		contaminationPenalty, efficiencyBonus,
		total, maxPossible
	}
	*/
	var score = {
		sampleHandling: 0,
		chainOfCustody: 0,
		testSelection: 0,
		controlUsage: 0,
		interpretation: 0,
		conclusionQuality: 0,
		contaminationPenalty: 0,
		efficiencyBonus: 0,
		total: 0,
		maxPossible: 0
	};

	// -- 1. Sample Handling (0 to SCORE_WEIGHTS.sampleHandling) --
	// +2 per sample collected with gloves on
	// -3 per sample collected without gloves (contaminated)
	var samples = gameState.collectedSamples;
	for (var s = 0; s < samples.length; s++) {
		if (samples[s].contaminated) {
			score.sampleHandling -= 3;
		} else {
			score.sampleHandling += 2;
		}
	}
	score.sampleHandling = clampScore(score.sampleHandling, 0, SCORE_WEIGHTS.sampleHandling);

	// -- 2. Chain of Custody (0 to SCORE_WEIGHTS.chainOfCustody) --
	// +2 per sample with matching label (type matches actual type)
	// +1 per sample with location notes
	for (var c = 0; c < samples.length; c++) {
		// Check if player-selected evidence type matches actual type
		if (samples[c].evidenceType === samples[c].actualType) {
			score.chainOfCustody += 2;
		}
		// Check if location notes were provided
		if (samples[c].locationNotes && samples[c].locationNotes.length > 3) {
			score.chainOfCustody += 1;
		}
	}
	score.chainOfCustody = clampScore(score.chainOfCustody, 0, SCORE_WEIGHTS.chainOfCustody);

	// -- 3. Test Selection (0 to SCORE_WEIGHTS.testSelection) --
	// +5 per test run on compatible sample type
	// -3 per test run on incompatible sample type
	var results = gameState.testResults;
	for (var t = 0; t < results.length; t++) {
		var result = results[t];
		if (result.success) {
			score.testSelection += 5;
		} else if (result.data && result.data.error &&
			result.data.error.indexOf('Incompatible') !== -1) {
			// Incompatible sample type penalty
			score.testSelection -= 3;
		}
	}
	score.testSelection = clampScore(score.testSelection, 0, SCORE_WEIGHTS.testSelection);

	// -- 4. Control Usage (0 to SCORE_WEIGHTS.controlUsage) --
	// +5 per test with control included
	// -2 per test without control
	for (var u = 0; u < results.length; u++) {
		if (results[u].controlIncluded) {
			score.controlUsage += 5;
		} else {
			score.controlUsage -= 2;
		}
	}
	score.controlUsage = clampScore(score.controlUsage, 0, SCORE_WEIGHTS.controlUsage);

	// -- 5. Interpretation (0 to SCORE_WEIGHTS.interpretation) --
	// Scan interpretation text from test results for scientific keywords
	var interpretationTotal = 0;
	for (var p = 0; p < results.length; p++) {
		if (results[p].playerInterpretation) {
			var evalResult = evaluateInterpretation(results[p].playerInterpretation);
			interpretationTotal += evalResult.score;
		}
	}
	score.interpretation = clampScore(interpretationTotal, 0, SCORE_WEIGHTS.interpretation);

	// -- 6. Conclusion Quality (0 to SCORE_WEIGHTS.conclusionQuality) --
	var conclusionEval = evaluateConclusion(gameState.currentConclusion);
	score.conclusionQuality = clampScore(conclusionEval.score, 0, SCORE_WEIGHTS.conclusionQuality);

	// -- 7. Contamination Penalty --
	// -3 per contamination event
	var contaminationPenalty = gameState.contaminationEvents * -3;
	// Cap uses absolute value of the weight (weight is already negative)
	score.contaminationPenalty = clampScore(
		contaminationPenalty,
		SCORE_WEIGHTS.contaminationPenalty,
		0
	);

	// -- 8. Efficiency Bonus --
	// +2 per unused swab (rewarding minimal collection)
	// +2 per unused test (rewarding targeted testing)
	var unusedSwabs = gameState.swabsRemaining;
	var unusedTests = gameState.testsRemaining;
	score.efficiencyBonus = (unusedSwabs * 2) + (unusedTests * 2);
	score.efficiencyBonus = clampScore(score.efficiencyBonus, 0, SCORE_WEIGHTS.efficiencyBonus);

	// -- Calculate total and max possible --
	score.total = score.sampleHandling
		+ score.chainOfCustody
		+ score.testSelection
		+ score.controlUsage
		+ score.interpretation
		+ score.conclusionQuality
		+ score.contaminationPenalty
		+ score.efficiencyBonus;

	// Max possible is the sum of all positive weight caps
	score.maxPossible = SCORE_WEIGHTS.sampleHandling
		+ SCORE_WEIGHTS.chainOfCustody
		+ SCORE_WEIGHTS.testSelection
		+ SCORE_WEIGHTS.controlUsage
		+ SCORE_WEIGHTS.interpretation
		+ SCORE_WEIGHTS.conclusionQuality
		+ SCORE_WEIGHTS.efficiencyBonus;

	return score;
}

/* ============================================ */
function clampScore(value, minVal, maxVal) {
	/*
	Restricts a numeric value to the given range.
	Args:
		value: number to clamp
		minVal: minimum allowed value
		maxVal: maximum allowed value
	Returns the clamped number.
	*/
	if (value < minVal) {
		return minVal;
	}
	if (value > maxVal) {
		return maxVal;
	}
	return value;
}

/* ============================================ */
function evaluateInterpretation(text) {
	/*
	Scores a single interpretation string for scientific
	language quality.
	Args:
		text: the player-written interpretation string
	Returns: { score: number, feedback: string }
	*/
	var result = { score: 0, feedback: '' };

	if (!text || text.length === 0) {
		result.feedback = 'No interpretation provided.';
		return result;
	}

	var lowerText = text.toLowerCase();
	var feedbackParts = [];

	// Check for good scientific keywords (+3 each)
	var goodCount = 0;
	for (var g = 0; g < GOOD_SCIENCE_KEYWORDS.length; g++) {
		if (lowerText.indexOf(GOOD_SCIENCE_KEYWORDS[g]) !== -1) {
			goodCount++;
			result.score += 3;
		}
	}
	if (goodCount > 0) {
		feedbackParts.push('Good use of scientific terminology (' + goodCount + ' terms)');
	}

	// Check for cautious/careful keywords (+2 each)
	var cautiousCount = 0;
	for (var c = 0; c < CAUTIOUS_SCIENCE_KEYWORDS.length; c++) {
		if (lowerText.indexOf(CAUTIOUS_SCIENCE_KEYWORDS[c]) !== -1) {
			cautiousCount++;
			result.score += 2;
		}
	}
	if (cautiousCount > 0) {
		feedbackParts.push('Appropriate caution in language (' + cautiousCount + ' terms)');
	}

	// Check for overclaiming keywords (-3 each)
	var overclaimCount = 0;
	for (var o = 0; o < OVERCLAIMING_KEYWORDS.length; o++) {
		if (lowerText.indexOf(OVERCLAIMING_KEYWORDS[o]) !== -1) {
			overclaimCount++;
			result.score -= 3;
		}
	}
	if (overclaimCount > 0) {
		feedbackParts.push('Warning: overclaiming detected (' + overclaimCount + ' instances)');
	}

	// Minimum score of 0 for individual interpretations
	if (result.score < 0) {
		result.score = 0;
	}

	// Build feedback string
	if (feedbackParts.length > 0) {
		result.feedback = feedbackParts.join('. ') + '.';
	} else {
		result.feedback = 'Consider using more precise scientific language.';
	}

	return result;
}

/* ============================================ */
function evaluateConclusion(text) {
	/*
	Scores the overall forensic conclusion text.
	Args:
		text: the player-written conclusion string
	Returns: { score: number, feedback: string, isOverclaiming: boolean }
	*/
	var result = { score: 0, feedback: '', isOverclaiming: false };

	if (!text || text.length === 0) {
		result.feedback = 'No conclusion was written. A forensic report always includes a conclusion.';
		return result;
	}

	var lowerText = text.toLowerCase();
	var feedbackParts = [];

	// +5 for mentioning specific evidence
	var evidenceRefCount = 0;
	for (var e = 0; e < EVIDENCE_REFERENCE_KEYWORDS.length; e++) {
		if (lowerText.indexOf(EVIDENCE_REFERENCE_KEYWORDS[e]) !== -1) {
			evidenceRefCount++;
		}
	}
	if (evidenceRefCount >= 2) {
		result.score += 5;
		feedbackParts.push('Good references to specific evidence');
	} else if (evidenceRefCount === 1) {
		result.score += 2;
		feedbackParts.push('Some evidence references, but could be more specific');
	} else {
		feedbackParts.push('Conclusion should reference specific evidence collected');
	}

	// +5 for proper uncertainty language
	var uncertaintyCount = 0;
	for (var u = 0; u < UNCERTAINTY_KEYWORDS.length; u++) {
		if (lowerText.indexOf(UNCERTAINTY_KEYWORDS[u]) !== -1) {
			uncertaintyCount++;
		}
	}
	if (uncertaintyCount >= 2) {
		result.score += 5;
		feedbackParts.push('Appropriate use of uncertainty language');
	} else if (uncertaintyCount === 1) {
		result.score += 2;
		feedbackParts.push('Some uncertainty acknowledged');
	} else {
		feedbackParts.push('Forensic conclusions should express appropriate uncertainty');
	}

	// +5 for logical reasoning words
	var reasoningCount = 0;
	for (var r = 0; r < REASONING_KEYWORDS.length; r++) {
		if (lowerText.indexOf(REASONING_KEYWORDS[r]) !== -1) {
			reasoningCount++;
		}
	}
	if (reasoningCount >= 2) {
		result.score += 5;
		feedbackParts.push('Strong logical reasoning');
	} else if (reasoningCount === 1) {
		result.score += 2;
		feedbackParts.push('Some logical structure present');
	} else {
		feedbackParts.push('Add reasoning that connects evidence to conclusion');
	}

	// -5 for overclaiming
	var overclaimCount = 0;
	for (var o = 0; o < OVERCLAIMING_KEYWORDS.length; o++) {
		if (lowerText.indexOf(OVERCLAIMING_KEYWORDS[o]) !== -1) {
			overclaimCount++;
		}
	}
	if (overclaimCount > 0) {
		result.score -= 5;
		result.isOverclaiming = true;
		feedbackParts.push('WARNING: Avoid absolute statements in forensic conclusions');
	}

	// Bonus for length (substantive conclusions)
	if (text.length > 200) {
		result.score += 3;
		feedbackParts.push('Thorough analysis');
	} else if (text.length > 100) {
		result.score += 1;
	}

	// Floor at 0
	if (result.score < 0) {
		result.score = 0;
	}

	result.feedback = feedbackParts.join('. ') + '.';
	return result;
}

/* ============================================ */
function calculateFinalScore() {
	/*
	Calculates the complete final game score.
	Sums all round scores and adds bonus/penalty for
	accusation correctness.
	Returns: {
		roundTotal, accusationBonus, total, maxPossible,
		isCorrectAccusation
	}
	*/
	// Sum round scores
	var roundTotal = 0;
	var roundMaxTotal = 0;
	for (var i = 0; i < gameState.roundScores.length; i++) {
		roundTotal += gameState.roundScores[i].total;
		roundMaxTotal += gameState.roundScores[i].maxPossible;
	}

	// Accusation bonus/penalty
	var accusationBonus = 0;
	var isCorrect = false;

	if (gameState.accusationMade && gameState.accusedSuspect && gameState.killer) {
		isCorrect = (gameState.accusedSuspect.id === gameState.killer.id);

		if (isCorrect) {
			// +20 base bonus for correct accusation
			accusationBonus = 20;

			// +10 additional if player had strong evidence
			// (ran at least 3 tests with controls)
			var testsWithControls = 0;
			for (var t = 0; t < gameState.testResults.length; t++) {
				if (gameState.testResults[t].controlIncluded) {
					testsWithControls++;
				}
			}
			if (testsWithControls >= 3) {
				accusationBonus += 10;
			}
		} else {
			// -10 penalty for wrong accusation
			accusationBonus = -10;
		}
	}

	// Max possible includes accusation bonus
	var maxPossible = roundMaxTotal + 30;

	var total = roundTotal + accusationBonus;

	var finalResult = {
		roundTotal: roundTotal,
		accusationBonus: accusationBonus,
		total: total,
		maxPossible: maxPossible,
		isCorrectAccusation: isCorrect
	};
	return finalResult;
}

/* ============================================ */
/* educational.js */
/* ============================================ */

/* ============================================ */
/* SECTION 9: EDUCATIONAL CONTENT              */
/* ============================================ */

/* ============================================ */
function showHelp(topic) {
	/*
	Shows educational content in a modal dialog.
	Args:
		topic: string identifying the help topic to display
	Supported topics:
		general, blood_type, rflp, str, mtdna, restriction,
		evidence_collection, contamination, controls, interpretation
	*/
	var title = 'Help';
	var content = '';

	switch (topic) {
		case 'general':
			title = 'Forensic Science Overview';
			content = buildGeneralHelp();
			break;

		case 'blood_type':
			title = 'Blood Typing (ABO/Rh System)';
			content = buildBloodTypeHelp();
			break;

		case 'rflp':
			title = 'RFLP Analysis';
			content = buildRFLPHelp();
			break;

		case 'str':
			title = 'PCR/STR Profiling';
			content = buildSTRHelp();
			break;

		case 'mtdna':
			title = 'Mitochondrial DNA Analysis';
			content = buildMtDNAHelp();
			break;

		case 'restriction':
			title = 'Restriction Enzyme Digestion';
			content = buildRestrictionHelp();
			break;

		case 'evidence_collection':
			title = 'Evidence Collection and Chain of Custody';
			content = buildEvidenceCollectionHelp();
			break;

		case 'contamination':
			title = 'Contamination and Its Effects';
			content = buildContaminationHelp();
			break;

		case 'controls':
			title = 'Experimental Controls';
			content = buildControlsHelp();
			break;

		case 'interpretation':
			title = 'Interpreting Results Scientifically';
			content = buildInterpretationHelp();
			break;

		default:
			title = 'Help';
			content = '<p>No help content is available for this topic.</p>';
	}

	showModal(title, content);
}

/* ============================================ */
function buildGeneralHelp() {
	/*
	Returns HTML content for the general forensic science overview.
	*/
	var html = '';
	html += '<h3>How This Game Works</h3>';
	html += '<p>You are a forensic investigator tasked with identifying a killer ';
	html += 'from among the dinner party guests at the Graves mansion. ';
	html += 'Use real forensic techniques to collect and analyze DNA evidence.</p>';

	html += '<h3>Game Phases</h3>';
	html += '<ul>';
	html += '<li><strong>Crime Scene:</strong> Examine the room and collect biological ';
	html += 'evidence using swabs. Always put on gloves first!</li>';
	html += '<li><strong>Laboratory:</strong> Run forensic tests on your collected ';
	html += 'samples. Choose tests appropriate for your evidence type.</li>';
	html += '<li><strong>Case Board:</strong> Review results, assess suspects, ';
	html += 'and write your forensic conclusions.</li>';
	html += '</ul>';

	html += '<h3>Scoring</h3>';
	html += '<p>Your score is based on <em>scientific rigor</em>, not just ';
	html += 'getting the right answer. Points are awarded for:</p>';
	html += '<ul>';
	html += '<li>Proper evidence handling (wearing gloves)</li>';
	html += '<li>Accurate labeling and chain of custody</li>';
	html += '<li>Choosing appropriate tests for sample types</li>';
	html += '<li>Including experimental controls</li>';
	html += '<li>Using proper scientific language in interpretations</li>';
	html += '<li>Writing thorough, evidence-based conclusions</li>';
	html += '</ul>';

	html += '<h3>Tips</h3>';
	html += '<ul>';
	html += '<li>Quality over quantity -- targeted testing beats running every test.</li>';
	html += '<li>Never say "definitely" or "proves" -- forensic science deals ';
	html += 'in probabilities, not certainties.</li>';
	html += '<li>A contaminated sample can still be analyzed, but results ';
	html += 'may be unreliable.</li>';
	html += '<li>If a timer runs out, another suspect dies and the killer ';
	html += 'strikes again at a new location.</li>';
	html += '</ul>';

	return html;
}

/* ============================================ */
function buildBloodTypeHelp() {
	/*
	Returns HTML content explaining blood typing and the ABO system.
	*/
	var html = '';
	html += '<h3>What Is Blood Typing?</h3>';
	html += '<p>Blood typing determines a person\'s ABO blood group and Rh factor ';
	html += 'by testing how blood reacts with specific antibodies.</p>';

	html += '<h3>The ABO System</h3>';
	html += '<p>Red blood cells carry antigens on their surface. The ABO system ';
	html += 'classifies blood based on two antigens: A and B.</p>';
	html += '<table class="help-table">';
	html += '<tr><th>Blood Type</th><th>Antigens</th><th>Anti-A Reaction</th>';
	html += '<th>Anti-B Reaction</th></tr>';
	html += '<tr><td>A</td><td>A antigen</td><td>Agglutination</td><td>None</td></tr>';
	html += '<tr><td>B</td><td>B antigen</td><td>None</td><td>Agglutination</td></tr>';
	html += '<tr><td>AB</td><td>Both A and B</td><td>Agglutination</td>';
	html += '<td>Agglutination</td></tr>';
	html += '<tr><td>O</td><td>Neither</td><td>None</td><td>None</td></tr>';
	html += '</table>';

	html += '<h3>Rh Factor</h3>';
	html += '<p>The Rh factor (also called the D antigen) is either present (+) ';
	html += 'or absent (-). Testing with anti-D serum determines Rh status. ';
	html += 'About 85% of people are Rh-positive.</p>';

	html += '<h3>Forensic Use</h3>';
	html += '<p>Blood typing is a quick exclusionary test. It cannot uniquely ';
	html += 'identify a person (many people share the same blood type), ';
	html += 'but it <em>can</em> exclude suspects whose type does not match ';
	html += 'the evidence. For positive identification, DNA profiling is needed.</p>';

	html += '<h3>Real-World Note</h3>';
	html += '<p>Blood typing was one of the earliest forensic techniques, ';
	html += 'used in criminal cases since the early 1900s. The ABO system was ';
	html += 'discovered by Karl Landsteiner in 1901.</p>';

	return html;
}

/* ============================================ */
function buildRFLPHelp() {
	/*
	Returns HTML content explaining RFLP analysis.
	*/
	var html = '';
	html += '<h3>What Is RFLP?</h3>';
	html += '<p>Restriction Fragment Length Polymorphism (RFLP) analysis is a ';
	html += 'technique that cuts DNA at specific recognition sequences using ';
	html += 'restriction enzymes, then separates the resulting fragments ';
	html += 'by size using gel electrophoresis.</p>';

	html += '<h3>How It Works</h3>';
	html += '<p>Think of RFLP like cutting a long document at every place a ';
	html += 'specific word appears. Different people have the word at different ';
	html += 'positions, so the pieces end up being different sizes. ';
	html += 'By comparing piece sizes, you can tell if two documents ';
	html += '(DNA samples) came from the same source.</p>';
	html += '<ol>';
	html += '<li>DNA is extracted from the sample</li>';
	html += '<li>Restriction enzymes (like EcoRI, BamHI, HindIII) cut the DNA</li>';
	html += '<li>Fragments are separated by size on a gel (smaller fragments ';
	html += 'travel farther)</li>';
	html += '<li>The resulting band pattern is compared between samples</li>';
	html += '</ol>';

	html += '<h3>Interpreting Results</h3>';
	html += '<p>If two samples show the same band pattern for an enzyme, they ';
	html += 'are <em>consistent with</em> coming from the same source. ';
	html += 'Different patterns exclude a match. Degraded DNA may show ';
	html += 'missing bands, making interpretation more difficult.</p>';

	html += '<h3>Limitations</h3>';
	html += '<ul>';
	html += '<li>Requires relatively large amounts of DNA (microgram quantities)</li>';
	html += '<li>DNA must be intact -- degraded samples may give incomplete patterns</li>';
	html += '<li>The process takes longer than newer PCR-based methods</li>';
	html += '</ul>';

	html += '<h3>Real-World Note</h3>';
	html += '<p>RFLP was the first DNA profiling method used in criminal cases, ';
	html += 'introduced by Sir Alec Jeffreys in 1984. It has been largely ';
	html += 'replaced by STR analysis but remains important historically ';
	html += 'and for certain applications.</p>';

	return html;
}

/* ============================================ */
function buildSTRHelp() {
	/*
	Returns HTML content explaining PCR/STR profiling.
	*/
	var html = '';
	html += '<h3>What Is STR Profiling?</h3>';
	html += '<p>Short Tandem Repeat (STR) analysis examines specific regions of ';
	html += 'DNA where a short sequence (typically 2-6 base pairs) is repeated ';
	html += 'in tandem. The number of repeats varies between individuals, ';
	html += 'creating a unique "DNA fingerprint."</p>';

	html += '<h3>PCR Amplification</h3>';
	html += '<p>Before analysis, the target DNA regions are amplified using ';
	html += 'Polymerase Chain Reaction (PCR). PCR creates millions of copies ';
	html += 'from a tiny starting amount, which is why STR can work on ';
	html += 'much smaller samples than RFLP.</p>';

	html += '<h3>CODIS Loci</h3>';
	html += '<p>The FBI\'s Combined DNA Index System (CODIS) uses a standard set ';
	html += 'of STR loci for identification. Each person has two alleles ';
	html += '(variants) per locus -- one inherited from each parent. ';
	html += 'This game tests 8 CODIS loci, including D3S1358, vWA, ';
	html += 'FGA, and others.</p>';

	html += '<h3>Interpreting Results</h3>';
	html += '<ul>';
	html += '<li>Each locus shows two numbers (alleles), one from each parent</li>';
	html += '<li>A match at all loci is extremely strong evidence of identity</li>';
	html += '<li>A mismatch at even one locus can exclude a suspect</li>';
	html += '<li>Extra alleles at a locus may indicate a mixture of DNA ';
	html += 'from multiple people</li>';
	html += '<li>Missing loci ("dropout") can occur with degraded samples</li>';
	html += '</ul>';

	html += '<h3>Real-World Note</h3>';
	html += '<p>STR profiling is the current gold standard in forensic DNA ';
	html += 'identification. A full 20-locus profile has a random match ';
	html += 'probability of approximately 1 in a quintillion for unrelated ';
	html += 'individuals. CODIS contains over 21 million profiles as of 2024.</p>';

	return html;
}

/* ============================================ */
function buildMtDNAHelp() {
	/*
	Returns HTML content explaining mitochondrial DNA analysis.
	*/
	var html = '';
	html += '<h3>What Is Mitochondrial DNA?</h3>';
	html += '<p>Mitochondrial DNA (mtDNA) is a small circular genome found in ';
	html += 'the mitochondria of cells, separate from the nuclear DNA in ';
	html += 'chromosomes. Unlike nuclear DNA, mtDNA is inherited only from ';
	html += 'the mother (maternal inheritance).</p>';

	html += '<h3>Why Use mtDNA?</h3>';
	html += '<ul>';
	html += '<li>Each cell contains hundreds to thousands of copies of mtDNA, ';
	html += 'but only two copies of nuclear DNA</li>';
	html += '<li>This abundance makes mtDNA more likely to survive in degraded ';
	html += 'or old samples</li>';
	html += '<li>Hair shafts (without roots) contain mtDNA but no nuclear DNA, ';
	html += 'making mtDNA the only DNA option for rootless hair evidence</li>';
	html += '<li>Useful for ancient remains, bones, and severely degraded samples</li>';
	html += '</ul>';

	html += '<h3>Haplotypes</h3>';
	html += '<p>mtDNA variants are classified into haplotypes -- groups that ';
	html += 'share specific sequence patterns. Common haplotypes include H, J, ';
	html += 'K, T, U, and others. These haplotypes trace maternal lineages ';
	html += 'and can link individuals to the same maternal line.</p>';

	html += '<h3>Limitations</h3>';
	html += '<ul>';
	html += '<li>Cannot distinguish between individuals who share a maternal ';
	html += 'lineage (siblings, maternal relatives)</li>';
	html += '<li>Less discriminating than STR profiling -- many unrelated ';
	html += 'people share the same haplotype</li>';
	html += '<li>Best used for exclusion or in combination with other tests</li>';
	html += '</ul>';

	html += '<h3>Real-World Note</h3>';
	html += '<p>mtDNA analysis was instrumental in identifying remains from ';
	html += 'mass disasters and historical cases, including the identification ';
	html += 'of the Romanov royal family. It is also used in missing persons ';
	html += 'cases where only degraded remains are available.</p>';

	return html;
}

/* ============================================ */
function buildRestrictionHelp() {
	/*
	Returns HTML content explaining restriction enzyme digestion.
	*/
	var html = '';
	html += '<h3>What Are Restriction Enzymes?</h3>';
	html += '<p>Restriction enzymes are molecular scissors that cut DNA at ';
	html += 'specific recognition sequences. Each enzyme recognizes a unique ';
	html += 'sequence of 4-8 base pairs and cuts at or near that site.</p>';

	html += '<h3>Common Forensic Enzymes</h3>';
	html += '<table class="help-table">';
	html += '<tr><th>Enzyme</th><th>Source</th><th>Recognition Site</th></tr>';
	html += '<tr><td>EcoRI</td><td>E. coli</td><td>GAATTC</td></tr>';
	html += '<tr><td>BamHI</td><td>B. amyloliquefaciens</td><td>GGATCC</td></tr>';
	html += '<tr><td>HindIII</td><td>H. influenzae</td><td>AAGCTT</td></tr>';
	html += '</table>';

	html += '<h3>How It Works</h3>';
	html += '<p>When a restriction enzyme encounters its recognition sequence ';
	html += 'in a DNA strand, it cleaves the phosphodiester bonds, producing ';
	html += 'fragments. Because different individuals have different DNA ';
	html += 'sequences, the number and positions of cut sites vary, ';
	html += 'resulting in different fragment patterns.</p>';

	html += '<h3>Forensic Application</h3>';
	html += '<p>A restriction digest produces a set of fragments that can be ';
	html += 'separated by gel electrophoresis. Comparing fragment patterns ';
	html += 'between a crime scene sample and suspect samples can help ';
	html += 'establish or exclude matches. This is the basis of RFLP analysis.</p>';

	return html;
}

/* ============================================ */
function buildEvidenceCollectionHelp() {
	/*
	Returns HTML content about proper evidence handling.
	*/
	var html = '';
	html += '<h3>Proper Evidence Collection</h3>';
	html += '<p>The integrity of forensic evidence depends entirely on how it ';
	html += 'is collected, labeled, and stored. Improper handling can render ';
	html += 'evidence inadmissible in court or lead to false conclusions.</p>';

	html += '<h3>Key Principles</h3>';
	html += '<ul>';
	html += '<li><strong>Wear gloves:</strong> Always put on fresh gloves before ';
	html += 'touching any evidence. Your own DNA, oils, and skin cells will ';
	html += 'contaminate the sample.</li>';
	html += '<li><strong>Label everything:</strong> Each sample must have a unique ';
	html += 'identifier, the collector\'s name, date, time, and precise ';
	html += 'location where it was found.</li>';
	html += '<li><strong>Document the scene:</strong> Photograph evidence in place ';
	html += 'before collection. Note the surrounding context.</li>';
	html += '<li><strong>Use appropriate tools:</strong> Sterile swabs for biological ';
	html += 'fluids, tweezers for hairs, tape lifts for fibers.</li>';
	html += '</ul>';

	html += '<h3>Chain of Custody</h3>';
	html += '<p>Chain of custody is the documented, unbroken trail showing who ';
	html += 'handled evidence, when, and where, from collection through ';
	html += 'court presentation. Any gap in this chain can be challenged ';
	html += 'by defense attorneys and may lead to evidence being excluded.</p>';

	html += '<h3>In This Game</h3>';
	html += '<p>You earn points for proper handling: wearing gloves, accurately ';
	html += 'labeling your sample type, and recording location notes. ';
	html += 'Forgetting gloves results in contamination penalties.</p>';

	return html;
}

/* ============================================ */
function buildContaminationHelp() {
	/*
	Returns HTML content about contamination and its effects.
	*/
	var html = '';
	html += '<h3>What Is Contamination?</h3>';
	html += '<p>Contamination occurs when foreign DNA or biological material is ';
	html += 'introduced to an evidence sample. This can come from the ';
	html += 'investigator, other evidence, environmental sources, or ';
	html += 'improper laboratory handling.</p>';

	html += '<h3>Sources of Contamination</h3>';
	html += '<ul>';
	html += '<li>Touching evidence without gloves (skin cells, sweat)</li>';
	html += '<li>Talking, coughing, or sneezing over evidence (saliva droplets)</li>';
	html += '<li>Using non-sterile collection tools</li>';
	html += '<li>Cross-contamination between evidence samples</li>';
	html += '<li>Environmental DNA already present at the scene</li>';
	html += '</ul>';

	html += '<h3>Consequences</h3>';
	html += '<ul>';
	html += '<li>Mixed DNA profiles that are difficult or impossible to interpret</li>';
	html += '<li>False positive matches to innocent people</li>';
	html += '<li>Evidence ruled inadmissible in court proceedings</li>';
	html += '<li>Wrongful convictions or failed prosecutions</li>';
	html += '</ul>';

	html += '<h3>Prevention</h3>';
	html += '<p>Always wear gloves, use sterile equipment, change gloves between ';
	html += 'samples, and maintain careful documentation. In this game, ';
	html += 'the single most important step is putting on gloves before ';
	html += 'collecting any evidence.</p>';

	return html;
}

/* ============================================ */
function buildControlsHelp() {
	/*
	Returns HTML content explaining experimental controls.
	*/
	var html = '';
	html += '<h3>Why Controls Matter</h3>';
	html += '<p>Controls are reference samples run alongside your actual test ';
	html += 'to verify that the procedure worked correctly. Without controls, ';
	html += 'you cannot be confident that your results are valid.</p>';

	html += '<h3>Types of Controls</h3>';
	html += '<ul>';
	html += '<li><strong>Positive Control:</strong> A sample known to contain ';
	html += 'the target. If this does not produce a result, the test failed ';
	html += 'and your evidence results are unreliable.</li>';
	html += '<li><strong>Negative Control:</strong> A blank sample that should ';
	html += 'produce no result. If this shows a signal, contamination ';
	html += 'occurred during the test procedure.</li>';
	html += '</ul>';

	html += '<h3>In Forensic Testing</h3>';
	html += '<p>Every forensic DNA test in an accredited laboratory is run with ';
	html += 'both positive and negative controls. Defense attorneys routinely ';
	html += 'challenge results that lack proper controls.</p>';

	html += '<h3>In This Game</h3>';
	html += '<p>When running a test in the lab, you can choose to include a ';
	html += 'control. Including controls costs no extra resources but ';
	html += 'earns significant scoring points for scientific rigor. ';
	html += 'Omitting controls results in a score penalty.</p>';

	return html;
}

/* ============================================ */
function buildInterpretationHelp() {
	/*
	Returns HTML content about interpreting forensic results.
	*/
	var html = '';
	html += '<h3>Scientific Interpretation</h3>';
	html += '<p>Interpreting forensic results requires careful, evidence-based ';
	html += 'language. A forensic scientist must never overstate what the ';
	html += 'evidence shows.</p>';

	html += '<h3>Good Scientific Language</h3>';
	html += '<table class="help-table">';
	html += '<tr><th>Use</th><th>Avoid</th></tr>';
	html += '<tr><td>"consistent with"</td><td>"proves"</td></tr>';
	html += '<tr><td>"cannot be excluded"</td><td>"definitely"</td></tr>';
	html += '<tr><td>"the evidence supports"</td><td>"100% certain"</td></tr>';
	html += '<tr><td>"partial match observed"</td><td>"it is obvious that"</td></tr>';
	html += '<tr><td>"further testing recommended"</td>';
	html += '<td>"without a doubt"</td></tr>';
	html += '</table>';

	html += '<h3>Handling Uncertainty</h3>';
	html += '<p>Degraded samples, partial profiles, and mixed samples all ';
	html += 'introduce uncertainty. A good forensic scientist acknowledges ';
	html += 'these limitations rather than ignoring them. State what the ';
	html += 'evidence shows, what it does not show, and what additional ';
	html += 'testing might clarify.</p>';

	html += '<h3>Common Pitfalls</h3>';
	html += '<ul>';
	html += '<li>Confirmation bias: seeing what you expect rather than what ';
	html += 'the data actually shows</li>';
	html += '<li>Overclaiming: stating certainty beyond what the evidence ';
	html += 'supports</li>';
	html += '<li>Ignoring negative results: a test that excludes a suspect ';
	html += 'is just as important as one that includes them</li>';
	html += '<li>Prosecutor\'s fallacy: confusing "the probability of this ';
	html += 'evidence given innocence" with "the probability of innocence ';
	html += 'given this evidence"</li>';
	html += '</ul>';

	return html;
}

/* ============================================ */
function getTooltip(concept) {
	/*
	Returns a short tooltip text string for inline help.
	Args:
		concept: string key identifying the concept
	Returns a plain text string suitable for title attributes.
	*/
	var tooltips = {
		'allele': 'One of the variant forms of a gene or STR region. '
			+ 'Humans carry two alleles per locus, one from each parent.',

		'locus': 'A specific position on a chromosome where a gene or '
			+ 'marker is located. Plural: loci.',

		'electrophoresis': 'A technique that separates DNA fragments by '
			+ 'size using an electric field applied across a gel matrix. '
			+ 'Smaller fragments migrate farther.',

		'agglutination': 'The clumping of red blood cells when exposed to '
			+ 'an antibody that recognizes antigens on their surface. '
			+ 'Used in blood typing.',

		'restriction_enzyme': 'A protein that cuts DNA at a specific '
			+ 'recognition sequence. Different enzymes cut at different '
			+ 'sequences, producing unique fragment patterns.',

		'fragment': 'A piece of DNA produced by cutting with a restriction '
			+ 'enzyme or other method. Fragment sizes are measured in '
			+ 'base pairs (bp).',

		'haplotype': 'A set of genetic variants inherited together, '
			+ 'typically on the same chromosome or in mitochondrial DNA. '
			+ 'Used to trace ancestry and maternal lineage.',

		'pcr': 'Polymerase Chain Reaction -- a method that amplifies tiny '
			+ 'amounts of DNA into millions of copies, enabling analysis '
			+ 'of trace samples.',

		'codis': 'Combined DNA Index System -- the FBI database of DNA '
			+ 'profiles using standardized STR loci. Used to match '
			+ 'crime scene evidence to known individuals.',

		'chain_of_custody': 'The documented trail of who handled evidence, '
			+ 'when, and where, from crime scene to courtroom. Gaps in '
			+ 'this chain can invalidate evidence.',

		'control_sample': 'A reference sample with a known outcome, run '
			+ 'alongside test samples to verify that the procedure '
			+ 'worked correctly.',

		'degraded': 'DNA that has been damaged by environmental factors '
			+ 'such as heat, humidity, UV light, or bacterial action. '
			+ 'May produce incomplete or missing results.',

		'mixture': 'A sample containing DNA from two or more individuals. '
			+ 'Produces extra alleles at STR loci and complex RFLP '
			+ 'banding patterns, complicating interpretation.'
	};

	if (tooltips[concept]) {
		return tooltips[concept];
	}
	return 'No tooltip available for: ' + concept;
}

/* ============================================ */
function getTestExplanation(testType) {
	/*
	Returns an HTML string explaining what a test does
	and how to interpret the results.
	Used in the lab phase when displaying results.
	Args:
		testType: string key from FORENSIC_TESTS
	Returns HTML string.
	*/
	var html = '';

	switch (testType) {
		case 'blood_type':
			html += '<div class="test-explanation">';
			html += '<h4>Blood Typing Results</h4>';
			html += '<p>This test mixed the sample with anti-A, anti-B, and ';
			html += 'anti-D (Rh) antibodies. Agglutination (clumping) ';
			html += 'indicates the presence of the corresponding antigen.</p>';
			html += '<p><strong>How to read:</strong> A positive reaction ';
			html += 'with anti-A means the blood carries the A antigen. ';
			html += 'Combine reactions to determine the ABO group. ';
			html += 'Blood type alone cannot identify a person but can ';
			html += 'exclude suspects with incompatible types.</p>';
			html += '</div>';
			break;

		case 'rflp':
			html += '<div class="test-explanation">';
			html += '<h4>RFLP Gel Results</h4>';
			html += '<p>DNA was cut with restriction enzymes and separated ';
			html += 'by size on a gel. Each column shows the banding ';
			html += 'pattern for one enzyme.</p>';
			html += '<p><strong>How to read:</strong> Compare band positions ';
			html += 'between your evidence sample and suspect reference ';
			html += 'profiles. Matching bands at the same positions ';
			html += 'indicate consistency. Missing bands may result from ';
			html += 'DNA degradation, not necessarily exclusion.</p>';
			html += '</div>';
			break;

		case 'str':
			html += '<div class="test-explanation">';
			html += '<h4>STR Profile Results</h4>';
			html += '<p>PCR amplified specific CODIS loci and measured the ';
			html += 'number of tandem repeats at each. Each person has ';
			html += 'two alleles per locus.</p>';
			html += '<p><strong>How to read:</strong> Two numbers at each ';
			html += 'locus represent the allele pair. Compare these ';
			html += 'pairs against suspect profiles. All loci must match ';
			html += 'for a positive identification. Empty loci indicate ';
			html += 'dropout from degradation. More than two alleles ';
			html += 'at a locus suggests a DNA mixture.</p>';
			html += '</div>';
			break;

		case 'mtdna':
			html += '<div class="test-explanation">';
			html += '<h4>Mitochondrial DNA Results</h4>';
			html += '<p>The mitochondrial genome was sequenced and assigned ';
			html += 'a haplotype identifier based on known variation.</p>';
			html += '<p><strong>How to read:</strong> A matching haplotype ';
			html += 'means the evidence and suspect share a maternal ';
			html += 'lineage. This is consistent with a match but is ';
			html += 'less discriminating than STR -- many unrelated ';
			html += 'people share the same mtDNA haplotype. Best used ';
			html += 'for exclusion or to complement other tests.</p>';
			html += '</div>';
			break;

		case 'restriction':
			html += '<div class="test-explanation">';
			html += '<h4>Restriction Digest Results</h4>';
			html += '<p>DNA was cut with a specific restriction enzyme and ';
			html += 'the resulting fragments were measured.</p>';
			html += '<p><strong>How to read:</strong> Compare the fragment ';
			html += 'sizes and number of fragments between your evidence ';
			html += 'and suspect profiles. Matching fragment patterns ';
			html += 'support a common source. Extra fragments may ';
			html += 'indicate a mixed sample.</p>';
			html += '</div>';
			break;

		default:
			html += '<div class="test-explanation">';
			html += '<p>No explanation available for this test type.</p>';
			html += '</div>';
	}

	return html;
}

/* ============================================ */
function getEndGameSummary() {
	/*
	Returns HTML summarizing the forensic concepts the player
	encountered during the game. Lists each test type used
	and provides a brief educational note. Mentions strengths
	and areas for improvement.
	*/
	var html = '';

	// Collect all unique test types that were run
	var testTypesUsed = {};
	for (var i = 0; i < gameState.testResults.length; i++) {
		var testType = gameState.testResults[i].testType;
		testTypesUsed[testType] = true;
	}

	var typeKeys = Object.keys(testTypesUsed);

	if (typeKeys.length === 0) {
		html += '<p>No forensic tests were run during this investigation. ';
		html += 'Collecting evidence and running appropriate tests is ';
		html += 'essential for building a forensic case.</p>';
		return html;
	}

	html += '<p>During this investigation, you used the following forensic ';
	html += 'techniques:</p>';
	html += '<ul>';

	for (var t = 0; t < typeKeys.length; t++) {
		var key = typeKeys[t];
		html += '<li>';
		html += '<strong>' + getTestDisplayName(key) + ':</strong> ';
		html += getTestEducationalNote(key);
		html += '</li>';
	}
	html += '</ul>';

	// Summary of evidence handling
	var totalSamples = gameState.collectedSamples.length;
	var totalTests = gameState.testResults.length;
	var contaminated = gameState.contaminationEvents;

	html += '<h3>Investigation Statistics</h3>';
	html += '<ul>';
	html += '<li>Evidence samples collected: ' + totalSamples + '</li>';
	html += '<li>Forensic tests conducted: ' + totalTests + '</li>';
	html += '<li>Contamination events: ' + contaminated + '</li>';
	html += '<li>Rounds completed: ' + gameState.roundHistory.length + '</li>';
	html += '</ul>';

	// Brief takeaway
	if (contaminated === 0) {
		html += '<p>You maintained excellent evidence integrity throughout ';
		html += 'the investigation -- no contamination events occurred.</p>';
	} else {
		html += '<p>Remember: in real forensic work, even a single ';
		html += 'contamination event can compromise an entire case. ';
		html += 'Always prioritize proper evidence handling.</p>';
	}

	return html;
}

/* ============================================ */
function getTestDisplayName(testType) {
	/*
	Returns the human-readable display name for a test type.
	Args:
		testType: string key from FORENSIC_TESTS
	Returns a display name string.
	*/
	if (FORENSIC_TESTS[testType]) {
		return FORENSIC_TESTS[testType].name;
	}
	return testType;
}

/* ============================================ */
function getTestEducationalNote(testType) {
	/*
	Returns a brief educational note about a test type
	for the end-game summary.
	Args:
		testType: string key from FORENSIC_TESTS
	Returns a plain text educational note.
	*/
	var notes = {
		'blood_type': 'Blood typing is one of the oldest forensic tests. '
			+ 'While it cannot uniquely identify a person, it remains '
			+ 'valuable as a rapid exclusionary tool.',

		'rflp': 'RFLP was the first DNA fingerprinting method, pioneered '
			+ 'by Alec Jeffreys in 1984. It requires intact DNA and '
			+ 'larger sample sizes than modern methods.',

		'str': 'STR profiling is the current gold standard in forensic '
			+ 'DNA identification. The CODIS database uses STR loci '
			+ 'to match crime scene evidence nationwide.',

		'mtdna': 'Mitochondrial DNA analysis is essential for degraded '
			+ 'samples and rootless hair. Its maternal inheritance '
			+ 'pattern makes it useful for tracing family lineages.',

		'restriction': 'Restriction enzyme digestion is foundational to '
			+ 'molecular biology and RFLP analysis. Understanding '
			+ 'how enzymes cut DNA at specific sequences is key to '
			+ 'interpreting fragment patterns.'
	};

	if (notes[testType]) {
		return notes[testType];
	}
	return 'A forensic analysis technique used in DNA identification.';
}

/* ============================================ */
/* ui_rendering.js */
/* ============================================ */

/* ============================================ */
/* UI RENDERING - DOM Manipulation and Updates  */
/* ============================================ */

// Stored callback for the modal close button
var _modalCloseCallback = null;

/* ============================================ */
function renderSetupScreen() {
	/* Populate the setup screen with difficulty option cards and
	   suspect selection cards. Difficulty cards are clickable to
	   select one. Suspect cards are clickable to toggle selection.
	   The "Begin Investigation" button is enabled when 4-6 suspects
	   are selected. Default difficulty is medium. */

	// -- Difficulty options --
	var diffContainer = document.getElementById('difficulty-options');
	if (diffContainer) {
		var diffHtml = '';
		var diffKeys = ['easy', 'medium', 'hard'];
		for (var d = 0; d < diffKeys.length; d++) {
			var diffKey = diffKeys[d];
			var config = DIFFICULTY_CONFIG[diffKey];
			// Default to medium selected
			var selectedClass = (diffKey === 'medium') ? ' selected' : '';
			diffHtml += '<div class="difficulty-card' + selectedClass + '"';
			diffHtml += ' data-difficulty="' + diffKey + '"';
			diffHtml += ' onclick="selectDifficulty(\'' + diffKey + '\')">';
			diffHtml += '<h4>' + config.label + '</h4>';
			diffHtml += '<p class="diff-description">' + config.description + '</p>';
			diffHtml += '<div class="diff-details">';
			// Format the timer as M:SS
			var timerMin = Math.floor(config.timerSeconds / 60);
			var timerSec = config.timerSeconds % 60;
			var timerStr = timerMin + ':' + ((timerSec < 10) ? '0' + timerSec : timerSec);
			diffHtml += '<span>Timer: ' + timerStr + '</span>';
			diffHtml += '<span>Swabs: ' + config.swabsPerRound + '</span>';
			diffHtml += '<span>Tests: ' + config.testsPerRound + '</span>';
			diffHtml += '</div>';
			diffHtml += '</div>';
		}
		diffContainer.innerHTML = diffHtml;
	}

	// -- Suspect selection --
	var suspectContainer = document.getElementById('suspect-selection');
	if (suspectContainer) {
		var susHtml = '';
		for (var s = 0; s < CHARACTER_POOL.length; s++) {
			var character = CHARACTER_POOL[s];
			susHtml += '<div class="suspect-option"';
			susHtml += ' data-suspect-id="' + character.id + '"';
			susHtml += ' onclick="toggleSuspectSelection(\'' + character.id + '\')">';
			susHtml += '<div class="suspect-name">' + escapeHtml(character.name) + '</div>';
			susHtml += '<div class="suspect-role">' + escapeHtml(character.role) + '</div>';
			susHtml += '<div class="suspect-age">Age: ' + character.age + '</div>';
			susHtml += '</div>';
		}
		suspectContainer.innerHTML = susHtml;
	}

	// Update the suspect count display and button state
	updateSuspectCountDisplay();
}

/* ============================================ */
function selectDifficulty(difficultyKey) {
	/* Handle clicking a difficulty card on the setup screen.
	   Removes .selected from all difficulty cards and adds it
	   to the clicked one.

	Args:
		difficultyKey: string 'easy', 'medium', or 'hard'
	*/
	var cards = document.querySelectorAll('.difficulty-card');
	for (var i = 0; i < cards.length; i++) {
		cards[i].classList.remove('selected');
		if (cards[i].getAttribute('data-difficulty') === difficultyKey) {
			cards[i].classList.add('selected');
		}
	}
}

/* ============================================ */
function toggleSuspectSelection(suspectId) {
	/* Toggle whether a suspect option card is selected on the setup
	   screen. Adds or removes the .selected class and updates
	   the count display and button state.

	Args:
		suspectId: string ID of the suspect to toggle
	*/
	var cards = document.querySelectorAll('.suspect-option');
	for (var i = 0; i < cards.length; i++) {
		if (cards[i].getAttribute('data-suspect-id') === suspectId) {
			cards[i].classList.toggle('selected');
			break;
		}
	}
	updateSuspectCountDisplay();
}

/* ============================================ */
function updateSuspectCountDisplay() {
	/* Update the suspect count text and enable/disable the
	   "Begin Investigation" button based on the current selection
	   count (must be 4-6 suspects). */
	var selected = getSelectedSuspects();
	var count = selected.length;

	// Update count text
	var countDisplay = document.getElementById('suspect-count-display');
	if (countDisplay) {
		countDisplay.textContent = 'Selected: ' + count + ' / 4-6 required';
	}

	// Enable or disable the start button
	var startBtn = document.getElementById('btn-start-case');
	if (startBtn) {
		if (count >= 4 && count <= 6) {
			startBtn.disabled = false;
		} else {
			startBtn.disabled = true;
		}
	}
}

/* ============================================ */
function renderIntroBriefing() {
	/* Fill #intro-content with a dramatic narrative briefing that
	   sets the scene for the investigation. Lists the selected
	   suspects and their claimed alibis. */
	var introEl = document.getElementById('intro-content');
	if (!introEl) {
		return;
	}

	var html = '';

	// Dramatic opening narrative
	html += '<div class="intro-narrative">';
	html += '<h2>Case Briefing</h2>';
	html += '<p class="intro-dramatic">';
	html += 'You have been called to the estate of Dr. Victor Graves, ';
	html += 'a renowned criminologist found dead in his study during ';
	html += 'what was supposed to be an exclusive dinner party.';
	html += '</p>';
	html += '<p>';
	html += 'The local police have secured the scene, but they lack the ';
	html += 'forensic expertise to process the DNA evidence. As a forensic ';
	html += 'investigator, you must collect biological samples, run lab ';
	html += 'analyses, and piece together the evidence to identify the killer ';
	html += 'before they strike again.';
	html += '</p>';
	html += '<p>';
	html += 'The clock is ticking. If you take too long, the killer will ';
	html += 'eliminate another guest. Every round, you must collect evidence ';
	html += 'from the crime scene, analyze it in the laboratory, and update ';
	html += 'your case board with your findings.';
	html += '</p>';
	html += '</div>';

	// Difficulty summary
	var diffConfig = DIFFICULTY_CONFIG[gameState.difficulty];
	html += '<div class="intro-difficulty">';
	html += '<h3>Difficulty: ' + diffConfig.label + '</h3>';
	html += '<p>' + diffConfig.description + '</p>';
	html += '</div>';

	// Suspect profiles with alibis
	html += '<div class="intro-suspects">';
	html += '<h3>Suspects Present at the Dinner Party</h3>';
	html += '<div class="intro-suspect-list">';
	for (var i = 0; i < gameState.suspects.length; i++) {
		var suspect = gameState.suspects[i];
		html += '<div class="intro-suspect-card">';
		html += '<div class="intro-suspect-name">' + escapeHtml(suspect.name) + '</div>';
		html += '<div class="intro-suspect-role">' + escapeHtml(suspect.role) + '</div>';
		html += '<div class="intro-suspect-alibi">';
		html += '<strong>Alibi:</strong> ' + escapeHtml(suspect.alibi);
		html += '</div>';
		html += '<div class="intro-suspect-motive">';
		html += '<strong>Possible motive:</strong> ' + escapeHtml(suspect.motive);
		html += '</div>';
		html += '</div>';
	}
	html += '</div>';
	html += '</div>';

	// Final instruction
	html += '<div class="intro-instruction">';
	html += '<p>';
	html += 'Examine the evidence carefully. Use proper forensic protocols. ';
	html += 'Wear your gloves, label your samples, and let the science guide ';
	html += 'your conclusions. The truth is in the DNA.';
	html += '</p>';
	html += '</div>';

	introEl.innerHTML = html;
}

/* ============================================ */
function updatePhaseDisplay(phaseName) {
	/* Update the #phase-display text in the game header bar.

	Args:
		phaseName: string label for the current phase
	*/
	var phaseEl = document.getElementById('phase-display');
	if (phaseEl) {
		phaseEl.textContent = phaseName;
	}
}

/* ============================================ */
function updatePhaseNav(currentPhase) {
	/* Show or hide phase navigation buttons based on which
	   phase the player is currently in.

	Args:
		currentPhase: string 'scene', 'lab', or 'board'
	*/
	var btnScene = document.getElementById('btn-to-scene');
	var btnLab = document.getElementById('btn-to-lab');
	var btnBoard = document.getElementById('btn-to-board');
	var btnEndRound = document.getElementById('btn-end-round');

	// Hide all navigation buttons first
	if (btnScene) { btnScene.style.display = 'none'; }
	if (btnLab) { btnLab.style.display = 'none'; }
	if (btnBoard) { btnBoard.style.display = 'none'; }
	if (btnEndRound) { btnEndRound.style.display = 'none'; }

	// Show buttons based on current phase
	if (currentPhase === 'scene') {
		if (btnLab) { btnLab.style.display = 'inline-block'; }
		if (btnBoard) { btnBoard.style.display = 'inline-block'; }
		if (btnEndRound) { btnEndRound.style.display = 'inline-block'; }
	} else if (currentPhase === 'lab') {
		if (btnScene) { btnScene.style.display = 'inline-block'; }
		if (btnBoard) { btnBoard.style.display = 'inline-block'; }
		if (btnEndRound) { btnEndRound.style.display = 'inline-block'; }
	} else if (currentPhase === 'board') {
		if (btnScene) { btnScene.style.display = 'inline-block'; }
		if (btnLab) { btnLab.style.display = 'inline-block'; }
		if (btnEndRound) { btnEndRound.style.display = 'inline-block'; }
	}
}

/* ============================================ */
function updateRoundDisplay() {
	/* Update the #round-display text in the game header. */
	var roundEl = document.getElementById('round-display');
	if (roundEl) {
		roundEl.textContent = 'Round ' + gameState.round;
	}
}

/* ============================================ */
function updateScoreDisplay() {
	/* Update the #score-display text in the game header. */
	var scoreEl = document.getElementById('score-display');
	if (scoreEl) {
		scoreEl.textContent = 'Score: ' + gameState.totalScore;
	}
}

/* ============================================ */
function updateSuspectCards() {
	/* Render suspect cards in the #suspect-cards sidebar panel.
	   Each card shows the suspect's name, role, alive/dead status,
	   and suspicion level if set. Dead suspects are grayed out.
	   If the player is in the CASE_BOARD phase, cards are clickable
	   to open suspect notes. */
	var container = document.getElementById('suspect-cards');
	if (!container) {
		return;
	}

	var suspects = gameState.suspects;
	if (!suspects || suspects.length === 0) {
		container.innerHTML = '<p class="empty-state">No suspects loaded.</p>';
		return;
	}

	var html = '';
	for (var i = 0; i < suspects.length; i++) {
		var suspect = suspects[i];
		var cardClass = 'suspect-card';

		// Dead suspects get a special class
		if (!suspect.alive) {
			cardClass += ' suspect-dead';
		}

		// Make cards clickable in the case board phase
		var clickAttr = '';
		if (gameState.phase === PHASE.CASE_BOARD && suspect.alive) {
			clickAttr = ' onclick="openSuspectNotes(\'' + suspect.id + '\')"';
			cardClass += ' suspect-clickable';
		}

		html += '<div class="' + cardClass + '"' + clickAttr + '>';

		// Name
		html += '<div class="suspect-card-name">';
		html += escapeHtml(suspect.name);
		html += '</div>';

		// Role subtitle
		html += '<div class="suspect-card-role">';
		html += escapeHtml(suspect.role);
		html += '</div>';

		// Alive/Dead status indicator
		html += '<div class="suspect-status">';
		if (suspect.alive) {
			html += '<span class="status-alive">Alive</span>';
		} else {
			html += '<span class="status-dead">Deceased</span>';
		}
		html += '</div>';

		// Suspicion level from suspect notes (if any)
		var notes = gameState.suspectNotes[suspect.id];
		if (notes && notes.length > 0) {
			html += '<div class="suspect-notes-preview">';
			// Truncate long notes for the sidebar preview
			var preview = notes;
			if (preview.length > 50) {
				preview = preview.substring(0, 47) + '...';
			}
			html += escapeHtml(preview);
			html += '</div>';
		}

		html += '</div>';
	}

	container.innerHTML = html;
}

/* ============================================ */
function showModal(title, htmlContent, onCloseCallback) {
	/* Show the modal overlay with the given title and HTML content.
	   Removes the .modal-hidden class from #modal-overlay to display it.

	Args:
		title: string displayed as the modal heading
		htmlContent: raw HTML string for the modal body
		onCloseCallback: optional function called when the modal is closed
	*/
	var overlay = document.getElementById('modal-overlay');
	var contentEl = document.getElementById('modal-content');

	if (!overlay || !contentEl) {
		return;
	}

	// Store the close callback for the close button handler
	_modalCloseCallback = onCloseCallback || null;

	// Build the modal inner HTML with title and content
	var modalHtml = '';
	modalHtml += '<h2 class="modal-title">' + title + '</h2>';
	modalHtml += '<div class="modal-body">';
	modalHtml += htmlContent;
	modalHtml += '</div>';

	contentEl.innerHTML = modalHtml;

	// Show the modal overlay
	overlay.classList.remove('modal-hidden');
}

/* ============================================ */
function closeModal() {
	/* Hide the modal overlay by adding .modal-hidden.
	   Calls the stored onCloseCallback if one was provided. */
	var overlay = document.getElementById('modal-overlay');
	if (overlay) {
		overlay.classList.add('modal-hidden');
	}

	// Call the stored close callback if present
	if (typeof _modalCloseCallback === 'function') {
		var callback = _modalCloseCallback;
		// Clear the reference before calling to prevent double-fire
		_modalCloseCallback = null;
		callback();
	} else {
		_modalCloseCallback = null;
	}
}

/* ============================================ */
function showNotification(message, type) {
	/* Show a brief notification message at the top center of the screen.
	   The notification fades in, stays for 3 seconds, then fades out
	   and removes itself from the DOM.

	Args:
		message: text string to display
		type: string 'success', 'warning', 'error', or 'info'
	*/
	if (!type) {
		type = 'info';
	}

	// Create the notification element
	var notifEl = document.createElement('div');
	notifEl.className = 'game-notification notification-' + type;
	notifEl.textContent = message;

	// Style the notification for top-center positioning
	notifEl.style.position = 'fixed';
	notifEl.style.top = '20px';
	notifEl.style.left = '50%';
	notifEl.style.transform = 'translateX(-50%)';
	notifEl.style.padding = '10px 24px';
	notifEl.style.borderRadius = '6px';
	notifEl.style.zIndex = '10000';
	notifEl.style.fontWeight = 'bold';
	notifEl.style.fontSize = '14px';
	notifEl.style.opacity = '0';
	notifEl.style.transition = 'opacity 0.3s ease';
	notifEl.style.pointerEvents = 'none';

	// Set color based on notification type
	if (type === 'success') {
		notifEl.style.backgroundColor = '#2e7d32';
		notifEl.style.color = '#ffffff';
	} else if (type === 'warning') {
		notifEl.style.backgroundColor = '#f57f17';
		notifEl.style.color = '#ffffff';
	} else if (type === 'error') {
		notifEl.style.backgroundColor = '#c62828';
		notifEl.style.color = '#ffffff';
	} else {
		// info
		notifEl.style.backgroundColor = '#1565c0';
		notifEl.style.color = '#ffffff';
	}

	// Add to the document body
	document.body.appendChild(notifEl);

	// Trigger fade-in after a brief delay so the transition fires
	setTimeout(function() {
		notifEl.style.opacity = '1';
	}, 10);

	// Fade out and remove after 3 seconds
	setTimeout(function() {
		notifEl.style.opacity = '0';
		// Remove from DOM after the fade-out transition completes
		setTimeout(function() {
			if (notifEl.parentNode) {
				notifEl.parentNode.removeChild(notifEl);
			}
		}, 350);
	}, 3000);
}

/* ============================================ */
function getSelectedDifficulty() {
	/* Returns the currently selected difficulty from the setup screen.
	   Checks which .difficulty-card has the .selected class.

	Returns:
		string: 'easy', 'medium', or 'hard' (defaults to 'medium')
	*/
	var cards = document.querySelectorAll('.difficulty-card');
	for (var i = 0; i < cards.length; i++) {
		if (cards[i].classList.contains('selected')) {
			var diff = cards[i].getAttribute('data-difficulty');
			if (diff) {
				return diff;
			}
		}
	}
	// Default to medium if nothing is selected
	return 'medium';
}

/* ============================================ */
function getSelectedSuspects() {
	/* Returns an array of selected suspect ID strings from the
	   setup screen. Checks which .suspect-option elements have
	   the .selected class.

	Returns:
		array: suspect ID strings
	*/
	var selected = [];
	var cards = document.querySelectorAll('.suspect-option');
	for (var i = 0; i < cards.length; i++) {
		if (cards[i].classList.contains('selected')) {
			var suspectId = cards[i].getAttribute('data-suspect-id');
			if (suspectId) {
				selected.push(suspectId);
			}
		}
	}
	return selected;
}

/* ============================================ */
/* save_load.js */
/* ============================================ */

/* ============================================ */
/* SAVE/LOAD SYSTEM - LocalStorage Persistence */
/* ============================================ */

// LocalStorage key for the saved game
var SAVE_KEY = 'forensic_detective_save';

/* ============================================ */
function saveGame() {
	/* Save the current gameState to localStorage.
	   Creates a clean copy without the timerInterval reference
	   (which is non-serializable) and stores it as JSON.
	   Shows a brief "Game Saved" notification on success. */

	// Build a clean copy of gameState without the interval handle
	var saveData = {};
	var keys = Object.keys(gameState);
	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		// Skip the interval ID since it cannot be serialized
		if (key === 'timerInterval') {
			continue;
		}
		saveData[key] = gameState[key];
	}

	// Add a save timestamp for display purposes
	saveData.savedAt = Date.now();

	// Serialize and store
	var jsonStr = JSON.stringify(saveData);
	localStorage.setItem(SAVE_KEY, jsonStr);

	// Show a brief success notification
	showNotification('Game Saved', 'success');
}

/* ============================================ */
function loadGame() {
	/* Load gameState from localStorage.
	   Reads the saved JSON, parses it, and restores all fields
	   onto the global gameState object. Does NOT restart the timer;
	   the caller is responsible for resuming any active timer.

	Returns:
		boolean: true if a saved game was found and loaded,
		         false if no save exists or parsing failed
	*/
	var jsonStr = localStorage.getItem(SAVE_KEY);
	if (!jsonStr) {
		return false;
	}

	var saveData = null;
	try {
		saveData = JSON.parse(jsonStr);
	} catch (e) {
		return false;
	}

	if (!saveData || typeof saveData !== 'object') {
		return false;
	}

	// Restore each saved field onto the global gameState
	var keys = Object.keys(saveData);
	for (var i = 0; i < keys.length; i++) {
		var key = keys[i];
		// Skip internal save metadata
		if (key === 'savedAt') {
			continue;
		}
		gameState[key] = saveData[key];
	}

	// Ensure the timer interval is clean after loading
	gameState.timerInterval = null;
	gameState.timerRunning = false;

	return true;
}

/* ============================================ */
function loadAndResumeGame() {
	/* Called from the title screen "Continue Investigation" button.
	   Attempts to load a saved game and transition to the
	   appropriate phase. If no save is found, shows an error modal. */

	var loaded = loadGame();

	if (!loaded) {
		showModal(
			'No Saved Game',
			'<p>No saved investigation was found.</p>' +
			'<p>Start a new investigation to begin.</p>'
		);
		return;
	}

	// Transition to whichever phase the player was in when they saved
	var resumePhase = gameState.phase;

	// Validate the phase is a real game phase (not title or setup)
	if (resumePhase === PHASE.TITLE || resumePhase === PHASE.SETUP) {
		// If saved during setup or title, restart from setup
		transitionTo(PHASE.SETUP);
		return;
	}

	// Update header displays before transitioning
	updateRoundDisplay();
	updateScoreDisplay();
	updateSuspectCards();

	// Transition to the saved phase
	transitionTo(resumePhase);
}

/* ============================================ */
function deleteSave() {
	/* Remove the saved game from localStorage.
	   Silently succeeds even if no save exists. */
	localStorage.removeItem(SAVE_KEY);
}

/* ============================================ */
function hasSavedGame() {
	/* Check whether a saved game exists in localStorage.
	   Used to show or hide the "Continue" button on the title screen.

	Returns:
		boolean: true if a saved game is present, false otherwise
	*/
	var jsonStr = localStorage.getItem(SAVE_KEY);
	if (!jsonStr) {
		return false;
	}
	// Verify the stored data is valid JSON
	try {
		var parsed = JSON.parse(jsonStr);
		return (parsed && typeof parsed === 'object');
	} catch (e) {
		return false;
	}
}

/* ============================================ */
/* init.js */
/* ============================================ */

/* ============================================ */
/* INIT - Main Entry Point and Game Bootstrap  */
/* ============================================ */

/* ============================================ */
function initGame() {
	/* Main initialization function called when the DOM is ready.
	   Checks for a saved game to show or hide the continue button,
	   sets up keyboard shortcuts, and displays the title screen. */

	// 1. Check for a saved game and toggle the continue button
	var loadBtn = document.getElementById('btn-load-game');
	if (loadBtn) {
		if (hasSavedGame()) {
			loadBtn.style.display = 'inline-block';
		} else {
			loadBtn.style.display = 'none';
		}
	}

	// 2. Set up keyboard event listeners for shortcuts
	document.addEventListener('keydown', handleKeyboardShortcut);

	// 3. Show the title screen as the initial view
	transitionTo(PHASE.TITLE);
}

/* ============================================ */
function handleKeyboardShortcut(event) {
	/* Handle keyboard shortcut presses for navigation and modal control.
	   Escape closes the modal if open. Number keys 1-3 navigate
	   between game phases when in an active game phase.

	Args:
		event: KeyboardEvent from the keydown listener
	*/

	var key = event.key;

	// Escape: close modal if open
	if (key === 'Escape') {
		var overlay = document.getElementById('modal-overlay');
		if (overlay && !overlay.classList.contains('modal-hidden')) {
			closeModal();
			return;
		}
	}

	// Only process navigation shortcuts during active game phases
	var activePhases = [PHASE.SCENE, PHASE.LAB, PHASE.CASE_BOARD];
	var isActivePhase = false;
	for (var i = 0; i < activePhases.length; i++) {
		if (gameState.phase === activePhases[i]) {
			isActivePhase = true;
			break;
		}
	}
	if (!isActivePhase) {
		return;
	}

	// Do not intercept keys when the user is typing in an input field
	var activeElement = document.activeElement;
	if (activeElement) {
		var tagName = activeElement.tagName.toLowerCase();
		if (tagName === 'input' || tagName === 'textarea' || tagName === 'select') {
			return;
		}
	}

	// Number key navigation
	if (key === '1') {
		// Go to scene investigation
		enterScenePhase();
	} else if (key === '2') {
		// Go to laboratory
		enterLabPhase();
	} else if (key === '3') {
		// Go to case board
		enterCaseBoard();
	}
}

/* ============================================ */
// Start the game when the DOM is fully loaded
document.addEventListener('DOMContentLoaded', initGame);
</script>
</body>
</html>
